시작은 app.js에서 시작한다

- (여기서 app.js로 시작하는 것은 package.json에서 main을 app.js로 설정했기 때문에~)
    
    ### app.js
    

```jsx
require('dotenv').config();
const express = require('express');
const routes = require('./routes');
const cors = require('cors');
const morgan = require('morgan');
const appDataSource = require('./utils/typeorm');

const app = express();
const PORT = process.env.PORT;

app.use(express.json());
app.use(cors());
app.use(morgan('dev'));
app.use(routes);

const startServer = async () => {
  try {
    appDataSource.initialize()
    .then( () => {
      console.log('Data Source has been initialzed');
    })
    .catch( (err) => {
        console.error('error occured during data source initalization',err);
        appDataSource.destroy();
    })

    app.listen(PORT, () => console.log(`Server is listening on ${PORT}`));
  } catch (err) {
    console.error(err);
  }
}

startServer();
```

Javascript는 결국 위에서 아래로 좌에서 우로 진행하는 순서가 있으므로

1. require(’dotenv’).config() 를 제일 먼저 실행한다

require(요청한다) 는 우리가 해당 디렉토리에 설치한 npm( 유용한 라이브러리들이 모여있는곳) 에서 설치한 dotenv(환경변수를 Javascript 내에 있는 process.env에 내용을 추가 시켜주는 라이브러리) 를 요청(import) 하고 import한 그것을 config한다

config()의 기능은

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ea6944eb-7950-4197-a012-147fb59e8af0/Untitled.png)

Load .env file contents into process.env

.env 파일 콘텐츠를 불러와서 process.env에 넣어준다!

1. const express = require('express');

npm 에서 설치한 express(node.js를 쉽게 쓰게해주는 프레임워크)를 require로 요청하고 그걸 express 변수에 담는다

1. const routes = require(’./routes’);

우리가 만든 모듈들중 .(현재 위치)/routes을요청해온다.

이때 index.js로 제일 먼저 이동하게 된다! 모든 디렉토리에 첫번째는 Index.js로 간다!

### routes 디렉토리의 index.js

```jsx
const express = require('express');
const router = express.Router();

const userRouter = require('./userRouter');
const postRouter = require('./postRouter');
const likeRouter = require('./likeRouter');

router.use('/users', userRouter.router);
router.use("/posts", postRouter.router);
router.use("/likes", likeRouter.router);

module.exports = router;
```

1. const express = require(’express’); [app.js → index.js]

아까 위에서 보았던 express 프레임워크를 요청한다!

→ 여기서 알수있는 점은 js파일마다 필요한 경우엔 다 require해줘야한다!

1. const route = express.Router();

express의 내부 모듈인 Router()를 실행한 객체를 변수 router에 넣어준다!

라우터란 음식점의 키오스크 처럼 어디 모듈로 가야하는지 정해주는 것인데

index.js는 대분류 해준다.

1. const userRouter = require(’./userRouter’);

여기서 우리가 만든 모듈인 userRouter로 이동한다

### userRouter.js

```jsx
const express = require('express');
const userController = require('../controllers/userController');

const router = express.Router();

router.post('/signup', userController.signUp);

module.exports = {
    router
}
```

1. const express = require(’express’) [index.js → userRouter.js]

express를 호출한다~

1. const userController = require(’../controllers/userController);

우리가 만든 모듈인 userController로 이동한다 ..(이전 디렉토리)/controllers/userController

### userController.js

```jsx
const userService = require('../services/userService');
const bcrypt = require('bcrypt');

const signUp = async (req, res) => {
    try{
        const { name, email, profile_image, password } = req.body;

        if( !name || !email || !profile_image || !password ){
            return res.status(400).json({ message : 'Key Error'});
        }
        await userService.signUp( name, email, profile_image, password);
        return res.status(201).json({ message: 'User Created '});
    }
    catch (err) {
        console.log(err);
        return res.status(err.statusCode || 500).json({ message: err.message});
    }
};

module.exports = {
    signUp
}
```

1. const userService = require(’../services/userService’); [userController.js → userService.js]

우리가 만든 모듈인 userService.js로 이동한다!

### userService.js

```jsx
const userDao = require('../models/userDao');

const signUp = async ( name, email, profile_image, password) => {
    try{
    
    // console.log(password);
    // const pwValidation = new RegExp(
    //     '^(?=.*[A-Za-z])(?=.*[0-9])(?=.*[!@#$%^&*_])(?=.{8,20})'
    // );
    // if(!pwValidation.test(password)) {
    //     const err = new Error('INVALID_PASSWORD');
    //     err.statusCode = 400;
    //     throw err;
    // }

    const createUser = await userDao.createUser(
        name,
        email,
        profile_image,
        password
    );

    return createUser;
    }
    catch (err){
        console.log(err);
        const error = new Error('invalid data input');
        error.statusCode = 500;
        throw error;
    }
}
module.exports = {
    signUp
}
```

1. const userDao = require(’../models/userDao); [userService.js → userDao.js]

우리가 만든 모듈인 userDao.js로 이동한다

```jsx
const appDataSource = require('../utils/typeorm');

const createUser = async ( name, email, profile_image, password ) => {
    console.log(name, email, profile_image, password);
    try{
        return await appDataSource.query(
            `INSERT INTO users (
                name,
                email,
                profile_image,
                password
            ) VALUES (?,?,?,?);`
            ,[name, email, profile_image, password]
        );
    }
    catch (err){
        console.log(err);
        const error = new Error('invalid data input');
        error.statusCode = 500;
        throw error;
    }
};

module.exports = { createUser }
```

1. const appDataSource = require('../utils/typeorm'); [userDao.js → typeorm.js]

### typeorm.js

```jsx
const { DataSource } = require('typeorm');

const appDataSource = new DataSource({
    type: process.env.TYPEORM_CONNECTION,
    host: process.env.TYPEORM_HOST,
    port: process.env.TYPEORM_PORT,
    username: process.env.TYPEORM_USERNAME,
    password: process.env.TYPEORM_PASSWORD,
    database: process.env.TYPEORM_DATABASE
});
    
module.exports = appDataSource
```

1. const { DataSource } = require('typeorm');

{DataSource} 안에 typeorm을 요청한 값을 넣는다는 느낌???? 애매하다

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7333d50c-4049-4311-86a2-d01531d2673b/Untitled.png)

> typeorm 안에 {DataSource} 가있는데 이걸 가져온다는 건가요 ㅠㅠㅠ (질문 필요)

```
const appDataSource = new DataSource({
    type: process.env.TYPEORM_CONNECTION,
    host: process.env.TYPEORM_HOST,
    port: process.env.TYPEORM_PORT,
    username: process.env.TYPEORM_USERNAME,
    password: process.env.TYPEORM_PASSWORD,
    database: process.env.TYPEORM_DATABASE
});
```

typeorm에서 가져온? 이런느낌인가 DataSource class 를 이용해서 appDataSource라는 인스턴스를 만든다 DataSource는 붕어빵 틀이고 appDataSource는 붕어빵(인스턴스)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/97c3b782-065d-42b4-8ff2-d96d7c41f66e/Untitled.png)

정말 클래스다

여기서 우리가 사용하고 있는 rdbms는 mysql 이므로 mysqlConnectionCredentialsOptions.d.ts로 들어가면

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a4ec2231-9bb0-4e4d-8f29-5310726f26e4/Untitled.png)

우리가 환경변수로 설정해준 것들이 여기에 있따

export는 수출하다이므로 다른곳에 쓸수 있게 되는것이다

interface는 class의 메서드만 있는 부분인데. interface는 실행을 무조건 해야한다.

즉 위 사진에서는 mysql 에 연결하기 위한 필수 옵션? 권한옵션 들이고

이값을 설정하는동작이

```jsx
const appDataSource = new DataSource({
    type: process.env.TYPEORM_CONNECTION,
    host: process.env.TYPEORM_HOST,
    port: process.env.TYPEORM_PORT,
    username: process.env.TYPEORM_USERNAME,
    password: process.env.TYPEORM_PASSWORD,
    database: process.env.TYPEORM_DATABASE
});
```

요것입니다!

14.module.exports = appDataSource

appDataSource 객체 (클래스에서 나온 인스턴스) 를 나를 요청했던 곳에 보내준다!

그럼 userDao.js로 돌아와서 (userDao.js의 첫째줄 실행 이후 다음줄부터)

1. createUser 함수선언 [typeorm.js → userDao.js]

```jsx
const createUser = async ( name, email, profile_image, password ) => {
    console.log(name, email, profile_image, password);
    try{
        return await appDataSource.query(
            `INSERT INTO users (
                name,
                email,
                profile_image,
                password
            ) VALUES (?,?,?,?);`
            ,[name, email, profile_image, password]
        );
    }
    catch (err){
        console.log(err);
        const error = new Error('invalid data input');
        error.statusCode = 500;
        throw error;
    }
};
```

appDataSource (DataSource의 인스턴스 객체) 의 query는

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4acfa8a8-e38f-44bb-8ff9-a84de393bdaa/Untitled.png)

raw SQL query를 실행하고 db 의 결과줄로 리턴한다!

1. module.exports = { createUser }

정확하게는 모르지만… 나 호출한 곳으로 불러온다( 외부에 뿌려준다)

createUser를 export할때는 {} 를써주고 appDataSource 엔 {}가 안붙은걸로 봐선

객체에는 {}안붙히고 함수엔 {} 붙히는구나 추측할수있따?

1. userService의 signUp 선언

```
const signUp = async ( name, email, profile_image, password) => {
    try{
    
    // console.log(password);
    // const pwValidation = new RegExp(
    //     '^(?=.*[A-Za-z])(?=.*[0-9])(?=.*[!@#$%^&*_])(?=.{8,20})'
    // );
    // if(!pwValidation.test(password)) {
    //     const err = new Error('INVALID_PASSWORD');
    //     err.statusCode = 400;
    //     throw err;
    // }

    const createUser = await userDao.createUser(
        name,
        email,
        profile_image,
        password
    );

    return createUser;
    }
    catch (err){
        console.log(err);
        const error = new Error('invalid data input');
        error.statusCode = 500;
        throw error;
    }
}
```

```
module.exports = {
    signUp
}
```

userService.js의 signUp함수를 요청가능하게 만들고, 호출한 곳으로 가즈아~

1. userController.js에 signUp 함수 선언

```jsx
const signUp = async (req, res) => {
    try{
        const { name, email, profile_image, password } = req.body;

        if( !name || !email || !profile_image || !password ){
            return res.status(400).json({ message : 'Key Error'});
        }
        await userService.signUp( name, email, profile_image, password);
        return res.status(201).json({ message: 'User Created '});
    }
    catch (err) {
        console.log(err);
        return res.status(err.statusCode || 500).json({ message: err.message});
    }
};
```

1. userController.js의 signUp함수 export해 (호출가능하게 해~)

```jsx
module.exports = {
    signUp
}
```

1. usrRouter.js

```
const router = express.Router();

router.post('/signup', userController.signUp);
```

express의 router 객체를? router에 넣고

그 변수로.post() 함수를 실행한다.

> 이때 ‘/signup’ 엔드포인트 가 실행되면

> userControll.signUp 함수를 실행한다? (eventlistener처럼?)

> 아 이때 userController userService userDao의 함수들이 실행되는느낌쓰

1. userRouter.js의 router 호출가능하게 해~

```
module.exports = {
    router
}
```

> 여긴 왜 {}를 쓸까? 아! 함수는 {} 객체는 {} 안쓰기인데 그래서 그런느낌이구나?

21 app.js에 라이브러리들 실행 ( const routes = require(’./routes’) 이후 )

```jsx
const cors = require('cors');
const morgan = require('morgan');

```

cors ⇒ 라이브러리로 브라우저 내의 SOP정책? 으로 인해 같은 컴퓨터 내에서만 통신이 가능한데 그걸 완화 시켜주는것

morgan ⇒ 로깅(로그를찍는) 을 도와주는 라이브러리

둘다 요청!

22 const appDataSource = require('./utils/typeorm');

DataSource 인스턴스 를 appDataSource에 넣기

23.const app = express();

express 인스턴스? 를 app에 넣기

24.const PORT = process.env.PORT;

process.env의 port값 변수에 넣기

```
app.use(express.json());
app.use(cors());
app.use(morgan('dev'));
app.use(routes);
```

express의 json() 함수 실행 / cors 실행 / morgan실행 / routes 실행

26 app.js의 startServer 함수 선언

```jsx
const startServer = async () => {
  try {
    appDataSource.initialize()
    .then( () => {
      console.log('Data Source has been initialzed');
    })
    .catch( (err) => {
        console.error('error occured during data source initalization',err);
        appDataSource.destroy();
    })

    app.listen(PORT, () => console.log(`Server is listening on ${PORT}`));
  } catch (err) {
    console.error(err);
  }
}
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8518a175-c086-4fab-9d43-d47a1e2b8285/Untitled.png)

initalize 함수를 이용해 데이터 베이스와 연결한다.

1. startServer();

함수 실행

위 방식으로 진행되는 느낌이다!

병민멘토님 ㄷ감사합니당!