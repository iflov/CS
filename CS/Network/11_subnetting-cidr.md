---
title: ÏÑúÎ∏åÎÑ§ÌåÖÍ≥º CIDR
created: 2025-01-03
updated: 2025-01-03
tags:
  - CS
  - Network
  - Subnetting
  - CIDR
  - IP
  - Subnet-Mask
category: Network
status: ÏôÑÎ£å
---

# üîÄ ÏÑúÎ∏åÎÑ§ÌåÖÍ≥º CIDR (Subnetting and CIDR)

## üìå Í∞úÏöî

ÏÑúÎ∏åÎÑ§ÌåÖ(Subnetting)ÏùÄ ÌïòÎÇòÏùò ÎÑ§Ìä∏ÏõåÌÅ¨Î•º Ïó¨Îü¨ Í∞úÏùò ÏûëÏùÄ ÎÑ§Ìä∏ÏõåÌÅ¨Î°ú Î∂ÑÌï†ÌïòÎäî Í∏∞Ïà†Ïù¥Î©∞, CIDR(Classless Inter-Domain Routing)Îäî ÌÅ¥ÎûòÏä§ ÏóÜÏù¥ Ïú†Ïó∞ÌïòÍ≤å IP Ï£ºÏÜåÎ•º Ìï†ÎãπÌïòÎäî Î∞©Î≤ïÏûÖÎãàÎã§. Ïù¥Î•º ÌÜµÌï¥ IP Ï£ºÏÜåÎ•º Ìö®Ïú®Ï†ÅÏúºÎ°ú Í¥ÄÎ¶¨ÌïòÍ≥† ÎùºÏö∞ÌåÖ ÌÖåÏù¥Î∏î ÌÅ¨Í∏∞Î•º Ï§ÑÏùº Ïàò ÏûàÏäµÎãàÎã§.

> [!info] ÌïµÏã¨ Í∞úÎÖê
> - **ÏÑúÎ∏åÎÑ§ÌåÖ**: ÎÑ§Ìä∏ÏõåÌÅ¨Î•º ÎÖºÎ¶¨Ï†ÅÏúºÎ°ú Î∂ÑÌï†
> - **ÏÑúÎ∏åÎÑ∑ ÎßàÏä§ÌÅ¨**: ÎÑ§Ìä∏ÏõåÌÅ¨ÏôÄ Ìò∏Ïä§Ìä∏ Î∂ÄÎ∂Ñ Íµ¨Î∂Ñ
> - **CIDR**: ÌÅ¥ÎûòÏä§Î¶¨Ïä§ Ï£ºÏÜå Ìï†Îãπ (/ÌëúÍ∏∞Î≤ï)
> - **VLSM**: Í∞ÄÎ≥Ä Í∏∏Ïù¥ ÏÑúÎ∏åÎÑ∑ ÎßàÏä§ÌÇπ

## üìö Î™©Ï∞®

1. [IP Ï£ºÏÜåÏùò Íµ¨ÏÑ±](#ip-Ï£ºÏÜåÏùò-Íµ¨ÏÑ±)
2. [ÏÑúÎ∏åÎÑ∑Í≥º ÏÑúÎ∏åÎÑ§ÌåÖ](#ÏÑúÎ∏åÎÑ∑Í≥º-ÏÑúÎ∏åÎÑ§ÌåÖ)
3. [CIDR ÌëúÍ∏∞Î≤ï](#cidr-ÌëúÍ∏∞Î≤ï)
4. [ÏÑúÎ∏åÎÑ∑ Í≥ÑÏÇ∞](#ÏÑúÎ∏åÎÑ∑-Í≥ÑÏÇ∞)
5. [VLSMÍ≥º ÏäàÌçºÎÑ§ÌåÖ](#vlsmÍ≥º-ÏäàÌçºÎÑ§ÌåÖ)
6. [Ïã§Ï†ú Íµ¨ÌòÑ ÏòàÏãú](#Ïã§Ï†ú-Íµ¨ÌòÑ-ÏòàÏãú)
7. [Ï∞∏Í≥† ÏûêÎ£å](#Ï∞∏Í≥†-ÏûêÎ£å)

## IP Ï£ºÏÜåÏùò Íµ¨ÏÑ±

### IPv4 Í∏∞Î≥∏ Íµ¨Ï°∞
```
IP Ï£ºÏÜå = Network ID + Host ID

Ïòà: 192.168.1.100
    ‚îÇ     ‚îÇ
    ‚îÇ     ‚îî‚îÄ Host ID (ÌäπÏ†ï Ìò∏Ïä§Ìä∏ ÏãùÎ≥Ñ)
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Network ID (ÎÑ§Ìä∏ÏõåÌÅ¨ ÏãùÎ≥Ñ)
```

### ÌÅ¥ÎûòÏä§Î≥Ñ Íµ¨Î∂Ñ
- **Class A**: Ï≤´ 8ÎπÑÌä∏Í∞Ä Network ID (0ÏúºÎ°ú ÏãúÏûë)
- **Class B**: Ï≤´ 16ÎπÑÌä∏Í∞Ä Network ID (10ÏúºÎ°ú ÏãúÏûë)
- **Class C**: Ï≤´ 24ÎπÑÌä∏Í∞Ä Network ID (110ÏúºÎ°ú ÏãúÏûë)
- **Class D**: Î©ÄÌã∞Ï∫êÏä§Ìä∏ (1110ÏúºÎ°ú ÏãúÏûë)
- **Class E**: ÏòàÏïΩÎê® (1111ÏúºÎ°ú ÏãúÏûë)

## ÏÑúÎ∏åÎÑ∑Í≥º ÏÑúÎ∏åÎÑ§ÌåÖ

### ÏÑúÎ∏åÎÑ§ÌåÖÏùò ÌïÑÏöîÏÑ±
1. **Ìö®Ïú®Ï†ÅÏù∏ IP Í¥ÄÎ¶¨**: ÌïÑÏöîÌïú ÎßåÌÅºÎßå IP Ìï†Îãπ
2. **Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ ÎèÑÎ©îÏù∏ Ï∂ïÏÜå**: ÎÑ§Ìä∏ÏõåÌÅ¨ Î∂ÄÌïò Í∞êÏÜå
3. **Î≥¥Ïïà Ìñ•ÏÉÅ**: Îßù Î∂ÑÎ¶¨Î•º ÌÜµÌïú Ï†ëÍ∑º Ï†úÏñ¥
4. **ÎùºÏö∞ÌåÖ Ìö®Ïú®ÏÑ±**: Í≥ÑÏ∏µÏ†Å ÎÑ§Ìä∏ÏõåÌÅ¨ Íµ¨ÏÑ±

### ÏÑúÎ∏åÎÑ∑ ÎßàÏä§ÌÅ¨
```
IP Ï£ºÏÜå:      11000000.10101000.00000001.01100100 (192.168.1.100)
ÏÑúÎ∏åÎÑ∑ ÎßàÏä§ÌÅ¨: 11111111.11111111.11111111.00000000 (255.255.255.0)
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Network ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ Host ‚îÄ‚îò
```

### ÏÑúÎ∏åÎÑ§ÌåÖ Ï†ÑÌõÑ ÎπÑÍµê
```
ÏÑúÎ∏åÎÑ§ÌåÖ Ï†Ñ (Class B):
172.16.0.0/16 ‚Üí 65,534Í∞ú Ìò∏Ïä§Ìä∏ (ÌïòÎÇòÏùò ÌÅ∞ ÎÑ§Ìä∏ÏõåÌÅ¨)

ÏÑúÎ∏åÎÑ§ÌåÖ ÌõÑ:
172.16.0.0/24  ‚Üí 254Í∞ú Ìò∏Ïä§Ìä∏
172.16.1.0/24  ‚Üí 254Í∞ú Ìò∏Ïä§Ìä∏
172.16.2.0/24  ‚Üí 254Í∞ú Ìò∏Ïä§Ìä∏
... (256Í∞úÏùò ÏûëÏùÄ ÎÑ§Ìä∏ÏõåÌÅ¨)
```

## CIDR ÌëúÍ∏∞Î≤ï

### CIDRÎûÄ?
- **Classless Inter-Domain Routing**
- ÌÅ¥ÎûòÏä§ Í∞úÎÖê ÏóÜÏù¥ ÎÑ§Ìä∏ÏõåÌÅ¨ ÎπÑÌä∏ ÏàòÎ•º Î™ÖÏãú
- Ïä¨ÎûòÏãú ÌëúÍ∏∞Î≤ï ÏÇ¨Ïö©: `IPÏ£ºÏÜå/ÌîÑÎ¶¨ÌîΩÏä§`

### CIDR ÌëúÍ∏∞ ÏòàÏãú
```
192.168.1.0/24
‚îú‚îÄ IP Ï£ºÏÜå: 192.168.1.0
‚îî‚îÄ ÌîÑÎ¶¨ÌîΩÏä§: 24ÎπÑÌä∏Í∞Ä ÎÑ§Ìä∏ÏõåÌÅ¨ Î∂ÄÎ∂Ñ

/24 = 255.255.255.0 (ÏÑúÎ∏åÎÑ∑ ÎßàÏä§ÌÅ¨)
/25 = 255.255.255.128
/26 = 255.255.255.192
/27 = 255.255.255.224
/28 = 255.255.255.240
/29 = 255.255.255.248
/30 = 255.255.255.252
/31 = 255.255.255.254
/32 = 255.255.255.255 (Îã®Ïùº Ìò∏Ïä§Ìä∏)
```

## ÏÑúÎ∏åÎÑ∑ Í≥ÑÏÇ∞

### Í≥ÑÏÇ∞ Í≥µÏãù
- **ÏÑúÎ∏åÎÑ∑ Ïàò**: 2^(ÎπåÎ¶∞ ÎπÑÌä∏ Ïàò)
- **Ìò∏Ïä§Ìä∏ Ïàò**: 2^(Ìò∏Ïä§Ìä∏ ÎπÑÌä∏ Ïàò) - 2
- **Î∏îÎ°ù ÌÅ¨Í∏∞**: 256 - ÏÑúÎ∏åÎÑ∑ ÎßàÏä§ÌÅ¨Ïùò ÎßàÏßÄÎßâ Ïò•ÌÖü

### Í≥ÑÏÇ∞ ÏòàÏ†ú
```
ÏòàÏ†ú: 218.128.32.0/24Î•º 60Í∞ú Ìò∏Ïä§Ìä∏Ïî© 4Í∞ú ÏÑúÎ∏åÎÑ∑ÏúºÎ°ú Î∂ÑÌï†

1. ÌïÑÏöî Ìò∏Ïä§Ìä∏ ÎπÑÌä∏: 2^6 = 64 > 60 ‚úì (6ÎπÑÌä∏ ÌïÑÏöî)
2. ÎÑ§Ìä∏ÏõåÌÅ¨ ÎπÑÌä∏: 32 - 6 = 26ÎπÑÌä∏ (/26)
3. Í∞Å ÏÑúÎ∏åÎÑ∑:
   - 218.128.32.0/26   (0-63)
   - 218.128.32.64/26  (64-127)
   - 218.128.32.128/26 (128-191)
   - 218.128.32.192/26 (192-255)
```

## VLSMÍ≥º ÏäàÌçºÎÑ§ÌåÖ

### VLSM (Variable Length Subnet Masking)
- ÏÑúÎ∏åÎÑ∑ÎßàÎã§ Îã§Î•∏ ÌÅ¨Í∏∞ Ìï†Îãπ
- IP Ï£ºÏÜå ÎÇ≠ÎπÑ ÏµúÏÜåÌôî
- Ìö®Ïú®Ï†ÅÏù∏ Ï£ºÏÜå Í≥µÍ∞Ñ ÌôúÏö©

### ÏäàÌçºÎÑ§ÌåÖ (Route Aggregation)
- Ïó¨Îü¨ ÏûëÏùÄ ÎÑ§Ìä∏ÏõåÌÅ¨Î•º ÌïòÎÇòÎ°ú ÌÜµÌï©
- ÎùºÏö∞ÌåÖ ÌÖåÏù¥Î∏î ÌÅ¨Í∏∞ Í∞êÏÜå
- CIDRÏùò Ïó≠Î∞©Ìñ• Í∞úÎÖê

```
Ïòà: 4Í∞úÏùò Class C ÎÑ§Ìä∏ÏõåÌÅ¨ ÌÜµÌï©
192.168.0.0/24
192.168.1.0/24  ‚Üí 192.168.0.0/22 (ÏäàÌçºÎÑ∑)
192.168.2.0/24
192.168.3.0/24
```

## Ïã§Ï†ú Íµ¨ÌòÑ ÏòàÏãú

### TypeScriptÎ°ú ÏÑúÎ∏åÎÑ§ÌåÖÍ≥º CIDR Íµ¨ÌòÑ

```typescript
// IP Ï£ºÏÜå Ïú†Ìã∏Î¶¨Ìã∞ ÌÅ¥ÎûòÏä§
class IPAddress {
  private octets: number[];
  
  constructor(ip: string) {
    this.octets = ip.split('.').map(n => parseInt(n));
    this.validate();
  }
  
  private validate(): void {
    if (this.octets.length !== 4) {
      throw new Error('Invalid IP address format');
    }
    for (const octet of this.octets) {
      if (octet < 0 || octet > 255) {
        throw new Error(`Invalid octet value: ${octet}`);
      }
    }
  }
  
  toInt32(): number {
    return this.octets.reduce((acc, octet, i) => {
      return acc | (octet << ((3 - i) * 8));
    }, 0) >>> 0;
  }
  
  static fromInt32(num: number): IPAddress {
    const octets = [
      (num >>> 24) & 0xFF,
      (num >>> 16) & 0xFF,
      (num >>> 8) & 0xFF,
      num & 0xFF
    ];
    return new IPAddress(octets.join('.'));
  }
  
  toString(): string {
    return this.octets.join('.');
  }
  
  toBinary(): string {
    return this.octets
      .map(o => o.toString(2).padStart(8, '0'))
      .join('.');
  }
}

// CIDR ÌÅ¥ÎûòÏä§
class CIDR {
  private baseIP: IPAddress;
  private prefixLength: number;
  
  constructor(cidr: string) {
    const [ip, prefix] = cidr.split('/');
    this.baseIP = new IPAddress(ip);
    this.prefixLength = parseInt(prefix);
    
    if (this.prefixLength < 0 || this.prefixLength > 32) {
      throw new Error(`Invalid prefix length: ${this.prefixLength}`);
    }
  }
  
  getSubnetMask(): IPAddress {
    const mask = (0xFFFFFFFF << (32 - this.prefixLength)) >>> 0;
    return IPAddress.fromInt32(mask);
  }
  
  getNetworkAddress(): IPAddress {
    const ipInt = this.baseIP.toInt32();
    const maskInt = this.getSubnetMask().toInt32();
    return IPAddress.fromInt32(ipInt & maskInt);
  }
  
  getBroadcastAddress(): IPAddress {
    const networkInt = this.getNetworkAddress().toInt32();
    const hostBits = 32 - this.prefixLength;
    const broadcastInt = networkInt | ((1 << hostBits) - 1);
    return IPAddress.fromInt32(broadcastInt);
  }
  
  getFirstHost(): IPAddress {
    const networkInt = this.getNetworkAddress().toInt32();
    return IPAddress.fromInt32(networkInt + 1);
  }
  
  getLastHost(): IPAddress {
    const broadcastInt = this.getBroadcastAddress().toInt32();
    return IPAddress.fromInt32(broadcastInt - 1);
  }
  
  getTotalHosts(): number {
    return Math.pow(2, 32 - this.prefixLength);
  }
  
  getUsableHosts(): number {
    const total = this.getTotalHosts();
    return total > 2 ? total - 2 : 0;
  }
  
  contains(ip: string): boolean {
    const testIP = new IPAddress(ip);
    const testInt = testIP.toInt32();
    const networkInt = this.getNetworkAddress().toInt32();
    const broadcastInt = this.getBroadcastAddress().toInt32();
    return testInt >= networkInt && testInt <= broadcastInt;
  }
  
  getInfo(): object {
    return {
      cidr: `${this.baseIP.toString()}/${this.prefixLength}`,
      network: this.getNetworkAddress().toString(),
      broadcast: this.getBroadcastAddress().toString(),
      subnetMask: this.getSubnetMask().toString(),
      firstHost: this.getFirstHost().toString(),
      lastHost: this.getLastHost().toString(),
      totalHosts: this.getTotalHosts(),
      usableHosts: this.getUsableHosts()
    };
  }
}

// ÏÑúÎ∏åÎÑ§ÌåÖ Í≥ÑÏÇ∞Í∏∞
class SubnetCalculator {
  // ÎÑ§Ìä∏ÏõåÌÅ¨Î•º ÎèôÏùº ÌÅ¨Í∏∞Î°ú Î∂ÑÌï†
  static divideEqually(cidr: string, subnetCount: number): CIDR[] {
    const network = new CIDR(cidr);
    const bitsNeeded = Math.ceil(Math.log2(subnetCount));
    const newPrefix = network['prefixLength'] + bitsNeeded;
    
    if (newPrefix > 30) {
      throw new Error('Cannot create subnets: prefix too long');
    }
    
    const subnets: CIDR[] = [];
    const networkInt = network.getNetworkAddress().toInt32();
    const subnetSize = Math.pow(2, 32 - newPrefix);
    
    for (let i = 0; i < Math.pow(2, bitsNeeded); i++) {
      const subnetInt = networkInt + (i * subnetSize);
      const subnetIP = IPAddress.fromInt32(subnetInt);
      subnets.push(new CIDR(`${subnetIP.toString()}/${newPrefix}`));
    }
    
    return subnets.slice(0, subnetCount);
  }
  
  // VLSM Í≥ÑÏÇ∞
  static vlsmAllocation(
    networkCidr: string,
    requirements: Array<{name: string, hosts: number}>
  ): Array<{name: string, subnet: CIDR, allocated: number}> {
    // ÏöîÍµ¨ÏÇ¨Ìï≠ÏùÑ Ìò∏Ïä§Ìä∏ Ïàò Í∏∞Ï§Ä ÎÇ¥Î¶ºÏ∞®Ïàú Ï†ïÎ†¨
    requirements.sort((a, b) => b.hosts - a.hosts);
    
    const allocations: Array<{name: string, subnet: CIDR, allocated: number}> = [];
    let currentNetwork = new CIDR(networkCidr);
    let currentIP = currentNetwork.getNetworkAddress().toInt32();
    
    for (const req of requirements) {
      // ÌïÑÏöîÌïú Ìò∏Ïä§Ìä∏ ÎπÑÌä∏ Í≥ÑÏÇ∞ (+2Îäî ÎÑ§Ìä∏ÏõåÌÅ¨ÏôÄ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏)
      const bitsNeeded = Math.ceil(Math.log2(req.hosts + 2));
      const prefixLength = 32 - bitsNeeded;
      
      // ÏÑúÎ∏åÎÑ∑ ÏÉùÏÑ±
      const subnetIP = IPAddress.fromInt32(currentIP);
      const subnet = new CIDR(`${subnetIP.toString()}/${prefixLength}`);
      
      allocations.push({
        name: req.name,
        subnet: subnet,
        allocated: subnet.getUsableHosts()
      });
      
      // Îã§Ïùå ÏÑúÎ∏åÎÑ∑ ÏãúÏûë Ï£ºÏÜå
      currentIP += Math.pow(2, bitsNeeded);
    }
    
    return allocations;
  }
  
  // ÏÑúÎ∏åÎÑ∑ ÏöîÏïΩ (ÏäàÌçºÎÑ§ÌåÖ)
  static summarize(cidrs: string[]): CIDR | null {
    if (cidrs.length === 0) return null;
    
    const networks = cidrs.map(c => new CIDR(c));
    const ips = networks.map(n => n.getNetworkAddress().toInt32());
    
    // Î™®Îì† IPÎ•º Ïù¥ÏßÑÏàòÎ°ú Î≥ÄÌôòÌïòÏó¨ Í≥µÌÜµ ÌîÑÎ¶¨ÌîΩÏä§ Ï∞æÍ∏∞
    let commonBits = 0;
    for (let bit = 31; bit >= 0; bit--) {
      const mask = 1 << bit;
      const firstBit = ips[0] & mask;
      
      if (ips.every(ip => (ip & mask) === firstBit)) {
        commonBits++;
      } else {
        break;
      }
    }
    
    const summaryPrefix = 32 - Math.ceil(Math.log2(
      Math.max(...ips) - Math.min(...ips) + 1
    ));
    
    const summaryIP = IPAddress.fromInt32(Math.min(...ips));
    return new CIDR(`${summaryIP.toString()}/${summaryPrefix}`);
  }
}

// ÏÑúÎ∏åÎÑ∑ ÏãúÍ∞ÅÌôî
class SubnetVisualizer {
  static visualizeBinary(cidr: string): void {
    const network = new CIDR(cidr);
    const ip = network.getNetworkAddress();
    const mask = network.getSubnetMask();
    
    console.log('=== Binary Visualization ===');
    console.log(`IP Address:    ${ip.toBinary()}`);
    console.log(`Subnet Mask:   ${mask.toBinary()}`);
    console.log(`               ${'‚ñ≤'.repeat(network['prefixLength'])}${'‚ñº'.repeat(32 - network['prefixLength'])}`);
    console.log(`               Network (${network['prefixLength']} bits) | Host (${32 - network['prefixLength']} bits)`);
  }
  
  static visualizeRange(cidr: string): void {
    const network = new CIDR(cidr);
    const info = network.getInfo() as any;
    
    console.log('\n=== IP Range Visualization ===');
    console.log('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
    console.log(`‚îÇ CIDR: ${info.cidr.padEnd(21)} ‚îÇ`);
    console.log('‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§');
    console.log(`‚îÇ Network:   ${info.network.padEnd(17)} ‚îÇ`);
    console.log(`‚îÇ First IP:  ${info.firstHost.padEnd(17)} ‚îÇ`);
    console.log(`‚îÇ ...        ${info.usableHosts} usable IPs`.padEnd(29) + ' ‚îÇ');
    console.log(`‚îÇ Last IP:   ${info.lastHost.padEnd(17)} ‚îÇ`);
    console.log(`‚îÇ Broadcast: ${info.broadcast.padEnd(17)} ‚îÇ`);
    console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');
  }
  
  static visualizeSubnets(parentCidr: string, subnets: CIDR[]): void {
    console.log('\n=== Subnet Division ===');
    console.log(`Parent: ${parentCidr}`);
    console.log('‚îÇ');
    
    subnets.forEach((subnet, i) => {
      const info = subnet.getInfo() as any;
      const isLast = i === subnets.length - 1;
      const prefix = isLast ? '‚îî‚îÄ' : '‚îú‚îÄ';
      
      console.log(`${prefix} ${info.cidr} (${info.usableHosts} hosts)`);
      
      if (!isLast) {
        console.log('‚îÇ');
      }
    });
  }
}

// Ïã§Ïäµ ÏòàÏ†ú
class NetworkDesignExample {
  static designCorporateNetwork(): void {
    console.log('=== Í∏∞ÏóÖ ÎÑ§Ìä∏ÏõåÌÅ¨ ÏÑ§Í≥Ñ ÏòàÏ†ú ===\n');
    console.log('ÏãúÎÇòÎ¶¨Ïò§: ÌöåÏÇ¨Ïóê 172.16.0.0/16 ÎÑ§Ìä∏ÏõåÌÅ¨ Ìï†Îãπ');
    console.log('ÏöîÍµ¨ÏÇ¨Ìï≠:');
    console.log('- Î≥∏ÏÇ¨: 500Î™Ö');
    console.log('- ÏßÄÏÇ¨1: 200Î™Ö');
    console.log('- ÏßÄÏÇ¨2: 100Î™Ö');
    console.log('- ÏÑúÎ≤ÑÌåú: 50ÎåÄ');
    console.log('- Í¥ÄÎ¶¨ÎÑ§Ìä∏ÏõåÌÅ¨: 20ÎåÄ\n');
    
    const requirements = [
      { name: 'Î≥∏ÏÇ¨', hosts: 500 },
      { name: 'ÏßÄÏÇ¨1', hosts: 200 },
      { name: 'ÏßÄÏÇ¨2', hosts: 100 },
      { name: 'ÏÑúÎ≤ÑÌåú', hosts: 50 },
      { name: 'Í¥ÄÎ¶¨ÎÑ§Ìä∏ÏõåÌÅ¨', hosts: 20 }
    ];
    
    const allocations = SubnetCalculator.vlsmAllocation(
      '172.16.0.0/16',
      requirements
    );
    
    console.log('=== VLSM Ìï†Îãπ Í≤∞Í≥º ===');
    console.log('Î∂ÄÏÑúÎ™Ö         | ÏÑúÎ∏åÎÑ∑           | Ìï†Îãπ IP | ÏöîÏ≤≠ IP');
    console.log('‚îÄ'.repeat(60));
    
    for (const alloc of allocations) {
      const info = alloc.subnet.getInfo() as any;
      const req = requirements.find(r => r.name === alloc.name)!;
      console.log(
        `${alloc.name.padEnd(13)} | ` +
        `${info.cidr.padEnd(16)} | ` +
        `${alloc.allocated.toString().padEnd(7)} | ` +
        `${req.hosts}`
      );
    }
    
    // Ìï†ÎãπÎêú ÏÑúÎ∏åÎÑ∑ ÏãúÍ∞ÅÌôî
    console.log('\n=== Ìï†ÎãπÎêú ÏÑúÎ∏åÎÑ∑ ÏÉÅÏÑ∏ ===');
    for (const alloc of allocations) {
      const info = alloc.subnet.getInfo() as any;
      console.log(`\n[${alloc.name}]`);
      console.log(`  ÎÑ§Ìä∏ÏõåÌÅ¨: ${info.network}`);
      console.log(`  ÏÇ¨Ïö©Î≤îÏúÑ: ${info.firstHost} - ${info.lastHost}`);
      console.log(`  ÏÑúÎ∏åÎÑ∑ÎßàÏä§ÌÅ¨: ${info.subnetMask}`);
    }
  }
  
  static demonstrateSubnetting(): void {
    console.log('\n=== ÏÑúÎ∏åÎÑ§ÌåÖ Ïã§Ïäµ ===\n');
    
    // Í∏∞Î≥∏ ÏÑúÎ∏åÎÑ∑ Ï†ïÎ≥¥
    const cidr = '192.168.1.0/24';
    console.log(`ÏõêÎ≥∏ ÎÑ§Ìä∏ÏõåÌÅ¨: ${cidr}`);
    
    const network = new CIDR(cidr);
    SubnetVisualizer.visualizeBinary(cidr);
    SubnetVisualizer.visualizeRange(cidr);
    
    // 4Í∞úÎ°ú Î∂ÑÌï†
    console.log('\n=== 4Í∞ú ÏÑúÎ∏åÎÑ∑ÏúºÎ°ú Î∂ÑÌï† ===');
    const subnets = SubnetCalculator.divideEqually(cidr, 4);
    SubnetVisualizer.visualizeSubnets(cidr, subnets);
    
    // IP Ìè¨Ìï® Ïó¨Î∂Ä ÌÖåÏä§Ìä∏
    console.log('\n=== IP Ìè¨Ìï® Ïó¨Î∂Ä ÌÖåÏä§Ìä∏ ===');
    const testIPs = ['192.168.1.50', '192.168.1.100', '192.168.1.200', '192.168.2.1'];
    
    for (const ip of testIPs) {
      for (const subnet of subnets) {
        if (subnet.contains(ip)) {
          const info = subnet.getInfo() as any;
          console.log(`${ip} ‚Üí ${info.cidr}`);
          break;
        }
      }
    }
  }
  
  static demonstrateSupernetting(): void {
    console.log('\n=== ÏäàÌçºÎÑ§ÌåÖ Ïã§Ïäµ ===\n');
    
    const networks = [
      '192.168.0.0/24',
      '192.168.1.0/24',
      '192.168.2.0/24',
      '192.168.3.0/24'
    ];
    
    console.log('Í∞úÎ≥Ñ ÎÑ§Ìä∏ÏõåÌÅ¨:');
    networks.forEach(n => console.log(`  - ${n}`));
    
    const summary = SubnetCalculator.summarize(networks);
    if (summary) {
      console.log(`\nÏöîÏïΩÎêú ÎÑ§Ìä∏ÏõåÌÅ¨: ${summary.getInfo().cidr}`);
      
      const info = summary.getInfo() as any;
      console.log(`Ï¥ù IP Ïàò: ${info.totalHosts}`);
      console.log(`Î≤îÏúÑ: ${info.network} - ${info.broadcast}`);
    }
  }
}

// Î©îÏù∏ Ïã§Ìñâ Ìï®Ïàò
function demonstrateSubnettingAndCIDR(): void {
  console.log('=== ÏÑúÎ∏åÎÑ§ÌåÖÍ≥º CIDR Ï¢ÖÌï© Ïã§Ïäµ ===\n');
  
  // 1. Í∏∞ÏóÖ ÎÑ§Ìä∏ÏõåÌÅ¨ ÏÑ§Í≥Ñ
  NetworkDesignExample.designCorporateNetwork();
  
  // 2. ÏÑúÎ∏åÎÑ§ÌåÖ Ïã§Ïäµ
  NetworkDesignExample.demonstrateSubnetting();
  
  // 3. ÏäàÌçºÎÑ§ÌåÖ Ïã§Ïäµ
  NetworkDesignExample.demonstrateSupernetting();
}

// Ïã§Ìñâ
// demonstrateSubnettingAndCIDR();
```

## üéØ ÌïµÏã¨ ÏöîÏïΩ

> [!important] ÌïµÏã¨ Ìè¨Ïù∏Ìä∏
> 1. **ÏÑúÎ∏åÎÑ§ÌåÖ**: ÌÅ∞ ÎÑ§Ìä∏ÏõåÌÅ¨Î•º ÏûëÏùÄ ÎÑ§Ìä∏ÏõåÌÅ¨Î°ú Î∂ÑÌï†
> 2. **CIDR**: /ÌëúÍ∏∞Î≤ïÏúºÎ°ú Ïú†Ïó∞Ìïú Ï£ºÏÜå Ìï†Îãπ
> 3. **ÏÑúÎ∏åÎÑ∑ ÎßàÏä§ÌÅ¨**: ÎÑ§Ìä∏ÏõåÌÅ¨ÏôÄ Ìò∏Ïä§Ìä∏ Íµ¨Î∂Ñ
> 4. **VLSM**: Í∞ÄÎ≥Ä Í∏∏Ïù¥Î°ú Ìö®Ïú®Ï†Å IP ÌôúÏö©
> 5. **Í≥ÑÏÇ∞ Í≥µÏãù**: 2^n (ÏÑúÎ∏åÎÑ∑ Ïàò), 2^n-2 (Ìò∏Ïä§Ìä∏ Ïàò)

## Ï∞∏Í≥† ÏûêÎ£å

### üìñ Ï∂îÍ∞Ä ÌïôÏäµ
- [Subnetting - Wikipedia](https://en.wikipedia.org/wiki/Subnetwork)
- [CIDR - RFC 4632](https://tools.ietf.org/html/rfc4632)
- [Visual Subnet Calculator](https://www.davidc.net/sites/default/subnets/subnets.html)
- [VLSM Tutorial](http://www.cisco.com/c/en/us/support/docs/ip/enhanced-interior-gateway-routing-protocol-eigrp/13788-3.html)

### üîó Í¥ÄÎ†® Î¨∏ÏÑú
- [[07_ip-addressing|IP Ï£ºÏÜå Ï≤¥Í≥Ñ]]
- [[08_network-components|ÎÑ§Ìä∏ÏõåÌÅ¨ Íµ¨ÏÑ±ÏöîÏÜå]]
- [[10_firewall-dns|Î∞©ÌôîÎ≤ΩÍ≥º DNS]]
