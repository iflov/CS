---
tags:
  - algorithm
  - performance
  - big-o
  - complexity
  - cs-fundamentals
created: 2025-01-04
updated: 2025-09-05
aliases:
  - ì•Œê³ ë¦¬ì¦˜ ì„±ëŠ¥
  - Big O í‘œê¸°ë²•
  - ì‹œê°„ ë³µì¡ë„
description: ì•Œê³ ë¦¬ì¦˜ì˜ ì„±ëŠ¥ ë¶„ì„ê³¼ Big O í‘œê¸°ë²•ì— ëŒ€í•œ ê¸°ì´ˆ ê°œë…
status: published
category: tutorial
---

# ì•Œê³ ë¦¬ì¦˜ ì„±ëŠ¥ê³¼ Big O í‘œê¸°ë²•

> [!info] ê°œìš”
> ì•Œê³ ë¦¬ì¦˜ì˜ ì„±ëŠ¥ì„ ë¶„ì„í•˜ê³  í‰ê°€í•˜ëŠ” ë°©ë²•ì„ í•™ìŠµí•©ë‹ˆë‹¤. ì‹œê°„ ë³µì¡ë„ì™€ ê³µê°„ ë³µì¡ë„ì˜ ê°œë…ì„ ì´í•´í•˜ê³ , Big O í‘œê¸°ë²•ì„ í†µí•´ ì•Œê³ ë¦¬ì¦˜ì˜ íš¨ìœ¨ì„±ì„ í‘œí˜„í•˜ëŠ” ë°©ë²•ì„ ìµí™ë‹ˆë‹¤.

## ğŸ“‘ ëª©ì°¨

- [[#âš¡ í•µì‹¬ ê°œë…]]
- [[#ğŸ¯ ì•Œê³ ë¦¬ì¦˜ ì„±ëŠ¥ í‰ê°€]]
- [[#ğŸ“Š ì‹œê°„ ë³µì¡ë„]]
- [[#ğŸ’¾ ê³µê°„ ë³µì¡ë„]]
- [[#ğŸ“ˆ Big O í‘œê¸°ë²•]]
- [[#ğŸ” ë³µì¡ë„ ë¶„ì„ ì˜ˆì œ]]
- [[#ğŸ’¡ ì‹¤ì „ íŒ]]
- [[#ğŸ“š ì°¸ê³ ìë£Œ]]

---

## âš¡ í•µì‹¬ ê°œë…

> [!note] ì•Œê³ ë¦¬ì¦˜ ì„±ëŠ¥ì´ë€?
> ì•Œê³ ë¦¬ì¦˜ì˜ ì„±ëŠ¥ì€ ì£¼ì–´ì§„ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ë° í•„ìš”í•œ **ì‹œê°„**ê³¼ **ê³µê°„(ë©”ëª¨ë¦¬)**ìœ¼ë¡œ ì¸¡ì •ë©ë‹ˆë‹¤.

### ì™œ ì•Œê³ ë¦¬ì¦˜ ì„±ëŠ¥ì´ ì¤‘ìš”í•œê°€?

1. **í™•ì¥ì„±(Scalability)**: ë°ì´í„°ê°€ ì»¤ì§ˆ ë•Œ í”„ë¡œê·¸ë¨ì´ ì—¬ì „íˆ íš¨ìœ¨ì ìœ¼ë¡œ ë™ì‘í•˜ëŠ”ê°€?
2. **ìì› ìµœì í™”**: í•œì •ëœ ì»´í“¨íŒ… ìì›ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ”ê°€?
3. **ì‚¬ìš©ì ê²½í—˜**: ë¹ ë¥¸ ì‘ë‹µ ì‹œê°„ìœ¼ë¡œ ë” ë‚˜ì€ ì‚¬ìš©ì ê²½í—˜ ì œê³µ

---

## ğŸ¯ ì•Œê³ ë¦¬ì¦˜ ì„±ëŠ¥ í‰ê°€

### ì„±ëŠ¥ ì¸¡ì • ê¸°ì¤€

> [!tip] ë‘ ê°€ì§€ ì£¼ìš” ì§€í‘œ
> - **ì‹œê°„ ë³µì¡ë„(Time Complexity)**: ì–¼ë§ˆë‚˜ ë¹¨ë¦¬ ì‹¤í–‰ë˜ëŠ”ê°€?
> - **ê³µê°„ ë³µì¡ë„(Space Complexity)**: ì–¼ë§ˆë‚˜ ë§ì€ ë©”ëª¨ë¦¬ë¥¼ ì‚¬ìš©í•˜ëŠ”ê°€?

### ì„±ëŠ¥ ë¶„ì„ ë°©ë²•

1. **ì‹¤í—˜ì  ë¶„ì„(Experimental Analysis)**
   - ì‹¤ì œ êµ¬í˜„ í›„ ì‹¤í–‰ ì‹œê°„ ì¸¡ì •
   - í•˜ë“œì›¨ì–´ì™€ í™˜ê²½ì— ì˜ì¡´ì 

2. **ì´ë¡ ì  ë¶„ì„(Theoretical Analysis)**
   - ìˆ˜í•™ì  ëª¨ë¸ì„ í†µí•œ ë¶„ì„
   - í•˜ë“œì›¨ì–´ ë…ë¦½ì 
   - Big O í‘œê¸°ë²• ì‚¬ìš©

---

## ğŸ“Š ì‹œê°„ ë³µì¡ë„

> [!info] ì •ì˜
> ì‹œê°„ ë³µì¡ë„ëŠ” ì…ë ¥ í¬ê¸°(n)ì— ë”°ë¥¸ ì•Œê³ ë¦¬ì¦˜ ì‹¤í–‰ ì‹œê°„ì˜ ì¦ê°€ìœ¨ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.

### ê¸°ë³¸ ì—°ì‚° ê³„ì‚°

```typescript
// ì˜ˆì œ 1: ìƒìˆ˜ ì‹œê°„ - O(1)
function getFirstElement<T>(arr: T[]): T {
   return arr[0];  // 1ë²ˆ ì‹¤í–‰
}

// ì˜ˆì œ 2: ì„ í˜• ì‹œê°„ - O(n)
function sumArray(arr: number[]): number {
   let total = 0;      // 1ë²ˆ
   for (const num of arr) {  // në²ˆ
       total += num;  // në²ˆ
   }
   return total;   // 1ë²ˆ
   // ì´: 2n + 2 â†’ O(n)
}

// ì˜ˆì œ 3: ì´ì°¨ ì‹œê°„ - O(nÂ²)
function bubbleSort(arr: number[]): void {
   const n = arr.length;
   for (let i = 0; i < n; i++) {      // në²ˆ
       for (let j = 0; j < n - 1; j++) {  // n-1ë²ˆ
           if (arr[j] > arr[j + 1]) {
               // TypeScriptì—ì„œ ìŠ¤ì™‘
               [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
           }
       }
   }
   // ì´: n * (n-1) â†’ O(nÂ²)
}
```

---

## ğŸ’¾ ê³µê°„ ë³µì¡ë„

> [!note] ì •ì˜
> ê³µê°„ ë³µì¡ë„ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ ì‹¤í–‰ë˜ëŠ” ë™ì•ˆ ì‚¬ìš©í•˜ëŠ” ë©”ëª¨ë¦¬ì˜ ì–‘ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.

### ê³µê°„ ë³µì¡ë„ êµ¬ì„± ìš”ì†Œ

1. **ê³ ì • ê³µê°„**: ì…ë ¥ í¬ê¸°ì™€ ë¬´ê´€í•œ ê³µê°„
   - ì½”ë“œ ì €ì¥ ê³µê°„
   - ë‹¨ìˆœ ë³€ìˆ˜
   - ìƒìˆ˜

2. **ê°€ë³€ ê³µê°„**: ì…ë ¥ í¬ê¸°ì— ë”°ë¼ ë³€í•˜ëŠ” ê³µê°„
   - ë™ì  í• ë‹¹ ë©”ëª¨ë¦¬
   - ì¬ê·€ í˜¸ì¶œ ìŠ¤íƒ
   - ì„ì‹œ ë³€ìˆ˜

> [!example] ê³µê°„ ë³µì¡ë„ ì˜ˆì œ
> ```typescript
> // O(1) ê³µê°„ ë³µì¡ë„
> function findMax(arr: number[]): number {
> 	let maxVal = arr[0];
> 	for (const num of arr){
> 		if(num > maxVal) {
> 			maxVal = num;
> 		}
> 	}
> 	return maxVal;
> }
> 
> // O(n) ê³µê°„ ë³µì¡ë„
> function createCopy(arr: number[]): number[] {
> 	const copy: number[] = [];
> 	for (const num of arr) {
> 		copy.push(num);
> 	}
> 	return copy;
> }
> ```

---

## ğŸ“ˆ Big O í‘œê¸°ë²•

> [!info] Big Oë€?
> Big O í‘œê¸°ë²•ì€ ì•Œê³ ë¦¬ì¦˜ì˜ ìµœì•…ì˜ ê²½ìš°(Worst Case) ì„±ëŠ¥ì„ ë‚˜íƒ€ë‚´ëŠ” ìˆ˜í•™ì  í‘œê¸°ë²•ì…ë‹ˆë‹¤.

### ì£¼ìš” Big O ë³µì¡ë„

| Big O | ëª…ì¹­ | ì˜ˆì œ | ì„±ëŠ¥ |
|-------|------|------|------|
| O(1) | ìƒìˆ˜ ì‹œê°„ | ë°°ì—´ ì¸ë±ìŠ¤ ì ‘ê·¼ | ìµœê³  âš¡ |
| O(log n) | ë¡œê·¸ ì‹œê°„ | ì´ì§„ íƒìƒ‰ | ìš°ìˆ˜ |
| O(n) | ì„ í˜• ì‹œê°„ | ë‹¨ìˆœ íƒìƒ‰ | ë³´í†µ |
| O(n log n) | ì„ í˜•ë¡œê·¸ ì‹œê°„ | íš¨ìœ¨ì ì¸ ì •ë ¬(ë¨¸ì§€, í€µ) | ì–‘í˜¸ |
| O(nÂ²) | ì´ì°¨ ì‹œê°„ | ì¤‘ì²© ë°˜ë³µë¬¸ | ë‚˜ì¨ |
| O(2â¿) | ì§€ìˆ˜ ì‹œê°„ | ì¬ê·€ í”¼ë³´ë‚˜ì¹˜ | ë§¤ìš° ë‚˜ì¨ |
| O(n!) | íŒ©í† ë¦¬ì–¼ ì‹œê°„ | ì™¸íŒì› ë¬¸ì œ | ìµœì•… âŒ |

### Big O ê·¸ë˜í”„

```
ì„±ëŠ¥ â†‘
    |     O(1) ____________
    |     
    |     O(log n) _____/
    |     
    |     O(n) ______/
    |    
    |     O(n log n) ___/
    |    
    |     O(nÂ²) ___/
    |    
    |     O(2â¿) _/
    |____________â†’ ì…ë ¥ í¬ê¸°(n)
```

### Big O ê³„ì‚° ê·œì¹™

> [!tip] ë‹¨ìˆœí™” ê·œì¹™
> 1. **ìƒìˆ˜ ì œê±°**: O(2n) â†’ O(n)
> 2. **ë‚®ì€ ì°¨ìˆ˜ ì œê±°**: O(nÂ² + n) â†’ O(nÂ²)
> 3. **ìƒìˆ˜ ê³±ì…ˆ ì œê±°**: O(3nÂ²) â†’ O(nÂ²)
> 4. **ì§€ë°°ì  í•­ë§Œ ìœ ì§€**: O(nÂ³ + nÂ² + n) â†’ O(nÂ³)

---

## ğŸ” ë³µì¡ë„ ë¶„ì„ ì˜ˆì œ

### ì˜ˆì œ 1: ë°°ì—´ì˜ ìµœëŒ“ê°’ ì°¾ê¸°

```typescript
function findMax(arr: number[]): number | null {
	if(!arr || arr.length === 0) {
		return null;
	}
	
	let maxVal = arr[0]; // O(1)
	
	for(let i = 1; i < arr.length; i++) { // O(n)
		if(arr[i] > maxVal) { // O(1)
			maxVal = arr[i]; // O(1)
		}
	}
	
	return maxVal; // O(1)
}

// ì‹œê°„ ë³µì¡ë„: O(n)
// ê³µê°„ ë³µì¡ë„: O(1)
```

### ì˜ˆì œ 2: ì´ì§„ íƒìƒ‰

```typescript
function binarySearch(arr: number[], target: number): number {
	let left = 0;
	let right = arr.length - 1; // O(1)
	
	while (left <= right) { // O(log n)
		const mid = Math.floor((left + right) / 2); // O(1)
		
		if(arr[mid] === target) {
			return mid;
		} else if (arr[mid] < target) {
			left = mid + 1;
		} else {
			right = mid - 1;
		}
	}
	
	return -1;
}

// ì‹œê°„ ë³µì¡ë„ O(log n)
// ê³µê°„ ë³µì¡ë„ O(1)
```

### ì˜ˆì œ 3: í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´ (ì¬ê·€ vs ë™ì  í”„ë¡œê·¸ë˜ë°)

```typescript
// ë¹„íš¨ìœ¨ì ì¸ ì¬ê·€ - O(2â¿)
function fibRecursive(n: number): number {
	if (n <= 1) {
		return n;
	}
	return fibRecursive(n - 1) + fibRecursive(n - 2);
}

// íš¨ìœ¨ì ì¸ ë™ì  í”„ë¡œê·¸ë˜ë° - O(n)
function fibDP(n: number): number {
	if (n <= 1) {
		return n;
	}
	
	const dp: number[] = new Array(n + 1).fill(0);
	dp[0] = 0;
	dp[1] = 1;
	
	for (let i = 2; i <= n; i++) {
		dp[i] = dp[i - 1] + dp[i - 2];
	}
	
	return dp[n];
}

```

> [!warning] ì¬ê·€ì˜ í•¨ì •
> ë‹¨ìˆœ ì¬ê·€ëŠ” ì¤‘ë³µ ê³„ì‚°ìœ¼ë¡œ ì¸í•´ ì§€ìˆ˜ ì‹œê°„ ë³µì¡ë„ë¥¼ ê°€ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

## ğŸ’¡ ì‹¤ì „ íŒ

> [!success] ì„±ëŠ¥ ìµœì í™” ì²´í¬ë¦¬ìŠ¤íŠ¸
> - [ ] ë¶ˆí•„ìš”í•œ ì¤‘ì²© ë°˜ë³µë¬¸ ì œê±°
> - [ ] ì ì ˆí•œ ìë£Œêµ¬ì¡° ì„ íƒ
> - [ ] ìºì‹±/ë©”ëª¨ì´ì œì´ì…˜ í™œìš©
> - [ ] ì¡°ê¸° ì¢…ë£Œ ì¡°ê±´ ì¶”ê°€
> - [ ] ë¶„í•  ì •ë³µ ê¸°ë²• ì ìš©

### ìë£Œêµ¬ì¡°ë³„ ì‹œê°„ ë³µì¡ë„

| ìë£Œêµ¬ì¡° | ì ‘ê·¼ | ê²€ìƒ‰ | ì‚½ì… | ì‚­ì œ |
|---------|------|------|------|------|
| ë°°ì—´ | O(1) | O(n) | O(n) | O(n) |
| ì—°ê²° ë¦¬ìŠ¤íŠ¸ | O(n) | O(n) | O(1) | O(1) |
| ìŠ¤íƒ/í | O(n) | O(n) | O(1) | O(1) |
| í•´ì‹œ í…Œì´ë¸” | - | O(1)* | O(1)* | O(1)* |
| ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ | O(log n)* | O(log n)* | O(log n)* | O(log n)* |

*í‰ê· ì ì¸ ê²½ìš°

### ì–¸ì œ ì–´ë–¤ ë³µì¡ë„ê°€ í—ˆìš©ë˜ëŠ”ê°€?

| ì…ë ¥ í¬ê¸°(n) | í—ˆìš© ê°€ëŠ¥í•œ ë³µì¡ë„ | ì˜ˆìƒ ì—°ì‚° íšŸìˆ˜ |
|-------------|------------------|---------------|
| n â‰¤ 10 | O(n!) | ~3,628,800 |
| n â‰¤ 20 | O(2â¿) | ~1,048,576 |
| n â‰¤ 100 | O(nÂ³) | ~1,000,000 |
| n â‰¤ 1,000 | O(nÂ²) | ~1,000,000 |
| n â‰¤ 100,000 | O(n log n) | ~1,660,964 |
| n â‰¤ 1,000,000 | O(n) | ~1,000,000 |
| n â‰¤ 10â¹ | O(log n) | ~30 |

---

## ğŸ“š ì°¸ê³ ìë£Œ

### ì¶”ê°€ í•™ìŠµ ìë£Œ
- [[02_divide-and-conquer|ë¶„í•  ì •ë³µ ì•Œê³ ë¦¬ì¦˜]]
- [[03_sorting-algorithms|ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ ë¹„êµ]]
- [Big-O Cheat Sheet](https://www.bigocheatsheet.com/)
- [Visualizing Algorithms](https://visualgo.net/)

### ì—°ìŠµ ë¬¸ì œ
1. ì£¼ì–´ì§„ ì½”ë“œì˜ ì‹œê°„ ë³µì¡ë„ ë¶„ì„í•˜ê¸°
2. O(nÂ²) ì•Œê³ ë¦¬ì¦˜ì„ O(n log n)ìœ¼ë¡œ ê°œì„ í•˜ê¸°
3. ê³µê°„ê³¼ ì‹œê°„ì˜ íŠ¸ë ˆì´ë“œì˜¤í”„ ìƒí™© ì°¾ê¸°

---

> [!quote]
> "Premature optimization is the root of all evil, but that doesn't mean we should write inefficient code." - Donald Knuth (ìˆ˜ì •ë¨)

---

## ğŸ”„ ì¬ê·€ ì•Œê³ ë¦¬ì¦˜ì˜ ë³µì¡ë„ ë¶„ì„

> [!info] ì¬ê·€ ë³µì¡ë„ì˜ íŠ¹ì§•
> ì¬ê·€ ì•Œê³ ë¦¬ì¦˜ì˜ ë³µì¡ë„ëŠ” **ì¬ê·€ ê¹Šì´**ì™€ **ê° ë ˆë²¨ì˜ ì‘ì—…ëŸ‰**ì„ ê³±í•˜ì—¬ ê³„ì‚°í•©ë‹ˆë‹¤. ì¬ê·€ ê´€ê³„ì‹(Recurrence Relation)ì„ í†µí•´ ì •í™•í•œ ë¶„ì„ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

### ì¬ê·€ ë³µì¡ë„ ê³„ì‚° ë°©ë²•

#### 1. ì¬ê·€ ê´€ê³„ì‹ ìˆ˜ë¦½

```python
# T(n) = ì¬ê·€ í˜¸ì¶œ ìˆ˜ Ã— T(ë¶€ë¶„ ë¬¸ì œ í¬ê¸°) + í˜„ì¬ ë ˆë²¨ ì‘ì—…ëŸ‰

# ì˜ˆ: íŒ©í† ë¦¬ì–¼
def factorial(n):
    if n <= 1:  # O(1)
        return 1
    return n * factorial(n-1)  # T(n-1) + O(1)

# T(n) = T(n-1) + O(1) = O(n)
```

#### 2. ë§ˆìŠ¤í„° ì •ë¦¬ (Master Theorem)

> [!note] ë§ˆìŠ¤í„° ì •ë¦¬ ê³µì‹
> T(n) = aÂ·T(n/b) + f(n) í˜•íƒœì˜ ì¬ê·€ì‹ì—ì„œ:
> - a: ì¬ê·€ í˜¸ì¶œ íšŸìˆ˜
> - b: ë¶€ë¶„ ë¬¸ì œ í¬ê¸° ë¹„ìœ¨
> - f(n): ë³‘í•©/ë¶„í•  ë¹„ìš©
>
> 1. f(n) = O(n^c), c < log_b(a) â†’ T(n) = O(n^log_b(a))
> 2. f(n) = O(n^c), c = log_b(a) â†’ T(n) = O(n^c log n)
> 3. f(n) = O(n^c), c > log_b(a) â†’ T(n) = O(f(n))

### ì¬ê·€ íŒ¨í„´ë³„ ë³µì¡ë„

#### ì„ í˜• ì¬ê·€ (Linear Recursion)

```python
# í•œ ë²ˆì˜ ì¬ê·€ í˜¸ì¶œ
def linear_sum(arr, n):
    if n == 0:
        return 0
    return arr[n-1] + linear_sum(arr, n-1)

# T(n) = T(n-1) + O(1) = O(n)
# ê³µê°„: O(n) - ì¬ê·€ ìŠ¤íƒ
```

#### ì´ì§„ ì¬ê·€ (Binary Recursion)

```python
# ë‘ ë²ˆì˜ ì¬ê·€ í˜¸ì¶œ - ë¹„íš¨ìœ¨ì 
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# T(n) = T(n-1) + T(n-2) + O(1) â‰ˆ O(2^n)
# ì •í™•íˆëŠ” O(Ï†^n) where Ï† = (1+âˆš5)/2 â‰ˆ 1.618
```

#### ë¶„í•  ì •ë³µ ì¬ê·€

```python
# ë³‘í•© ì •ë ¬ - íš¨ìœ¨ì ì¸ ë¶„í• 
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])   # T(n/2)
    right = merge_sort(arr[mid:])  # T(n/2)
    return merge(left, right)       # O(n)

# T(n) = 2Â·T(n/2) + O(n) = O(n log n)
```

### ì¬ê·€ â†’ ê¼¬ë¦¬ì¬ê·€ ìµœì í™”

> [!tip] ê¼¬ë¦¬ì¬ê·€ ìµœì í™”
> ê¼¬ë¦¬ì¬ê·€ëŠ” ì»´íŒŒì¼ëŸ¬ ìµœì í™”ë¥¼ í†µí•´ O(1) ê³µê°„ ë³µì¡ë„ë¥¼ ë‹¬ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```python
# ì¼ë°˜ ì¬ê·€ - O(n) ê³µê°„
def factorial_recursive(n):
    if n <= 1:
        return 1
    return n * factorial_recursive(n-1)

# ê¼¬ë¦¬ì¬ê·€ - O(1) ê³µê°„ (ìµœì í™” ì‹œ)
def factorial_tail(n, accumulator=1):
    if n <= 1:
        return accumulator
    return factorial_tail(n-1, n * accumulator)
```

### ì¬ê·€ íŠ¸ë¦¬ ë¶„ì„

```
í”¼ë³´ë‚˜ì¹˜ F(5) í˜¸ì¶œ íŠ¸ë¦¬:
                    F(5)
                   /    \
              F(4)        F(3)
             /    \      /    \
        F(3)      F(2)  F(2)  F(1)
       /    \     /  \  /  \
    F(2)   F(1) F(1) F(0) ...

ì´ í˜¸ì¶œ íšŸìˆ˜: ~O(2^n)
ì¤‘ë³µ ê³„ì‚°: F(3) 2ë²ˆ, F(2) 3ë²ˆ
```

### ë©”ëª¨ì´ì œì´ì…˜ì„ í†µí•œ ìµœì í™”

```python
# ë©”ëª¨ì´ì œì´ì…˜ìœ¼ë¡œ O(n) ì‹œê°„, O(n) ê³µê°„
def fib_memo(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    
    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)
    return memo[n]

# ê° ë¶€ë¶„ ë¬¸ì œë¥¼ í•œ ë²ˆë§Œ ê³„ì‚°
```

### ì¬ê·€ ë³µì¡ë„ ìš”ì•½í‘œ

| ì¬ê·€ ìœ í˜• | ì˜ˆì œ | ì‹œê°„ ë³µì¡ë„ | ê³µê°„ ë³µì¡ë„ |
|---------|------|------------|------------|
| ì„ í˜• ì¬ê·€ | íŒ©í† ë¦¬ì–¼, ì„ í˜• íƒìƒ‰ | O(n) | O(n) |
| ê¼¬ë¦¬ ì¬ê·€ | ìµœì í™”ëœ íŒ©í† ë¦¬ì–¼ | O(n) | O(1)* |
| ì´ì§„ ì¬ê·€ | í”¼ë³´ë‚˜ì¹˜(ìˆœì§„) | O(2^n) | O(n) |
| ë¶„í•  ì •ë³µ | ë³‘í•© ì •ë ¬ | O(n log n) | O(log n) |
| íŠ¸ë¦¬ ì¬ê·€ | í•˜ë…¸ì´ íƒ‘ | O(2^n) | O(n) |
| ë™ì  í”„ë¡œê·¸ë˜ë° | í”¼ë³´ë‚˜ì¹˜(ë©”ëª¨) | O(n) | O(n) |

*ì»´íŒŒì¼ëŸ¬ ìµœì í™” ì ìš© ì‹œ

### ì¬ê·€ ìµœì í™” ì „ëµ

> [!success] ìµœì í™” ì²´í¬ë¦¬ìŠ¤íŠ¸
> - [ ] ê¼¬ë¦¬ì¬ê·€ë¡œ ë³€í™˜ ê°€ëŠ¥í•œê°€?
> - [ ] ë©”ëª¨ì´ì œì´ì…˜ì´ ì ìš© ê°€ëŠ¥í•œê°€?
> - [ ] ë°˜ë³µë¬¸ìœ¼ë¡œ ë³€í™˜ì´ ë” íš¨ìœ¨ì ì¸ê°€?
> - [ ] ë¶€ë¶„ ë¬¸ì œ ì¤‘ë³µì´ ìˆëŠ”ê°€?
> - [ ] ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš° ìœ„í—˜ì´ ìˆëŠ”ê°€?

```python
# ì¬ê·€ ê¹Šì´ ì œí•œ í™•ì¸ ë° ì„¤ì •
import sys
print(sys.getrecursionlimit())  # ê¸°ë³¸: 1000
sys.setrecursionlimit(10000)    # ì¦ê°€ (ì£¼ì˜ í•„ìš”)
```

> [!warning] ì¬ê·€ ì‚¬ìš© ì‹œ ì£¼ì˜ì‚¬í•­
> - Pythonì€ ê¼¬ë¦¬ì¬ê·€ ìµœì í™”ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŒ
> - ê¹Šì€ ì¬ê·€ëŠ” ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš° ìœ„í—˜
> - ì¤‘ë³µ ê³„ì‚°ì´ ìˆë‹¤ë©´ ë°˜ë“œì‹œ ë©”ëª¨ì´ì œì´ì…˜ ê³ ë ¤

### ê´€ë ¨ ë¬¸ì„œ
- [[02_recursion-and-tail-recursion|ì¬ê·€ì™€ ê¼¬ë¦¬ì¬ê·€]]
- [[02_divide-and-conquer|ë¶„í•  ì •ë³µ ì•Œê³ ë¦¬ì¦˜]]

---

## ğŸ“Š Elementary Operationsì™€ ì‹œê°„ ë³µì¡ë„ ê³„ì‚°

> [!note] Elementary Operations (ê¸°ë³¸ ì—°ì‚°)
> ì‹œê°„ ë³µì¡ë„ë¥¼ ê³„ì‚°í•  ë•Œ ì‚¬ìš©ë˜ëŠ” ê¸°ë³¸ ì—°ì‚° ë‹¨ìœ„ì…ë‹ˆë‹¤:
> 1. **ëŒ€ì… ì—°ì‚°**: ë³€ìˆ˜ì— ê°’ì„ ì €ì¥
> 2. **ì‚¬ì¹™ ì—°ì‚°**: ë§ì…ˆ, ëº„ì…ˆ, ê³±ì…ˆ, ë‚˜ëˆ—ì…ˆ
> 3. **ë¹„êµ êµ¬ë¬¸**: if, while ë“±ì˜ ì¡°ê±´ ë¹„êµ
> 4. **í•¨ìˆ˜ í˜¸ì¶œ**: í•¨ìˆ˜ ì‹¤í–‰

### Statement Analysis Table (ë¬¸ì¥ë³„ ë¶„ì„)

```python
def sum_array(arr):
    total = 0      # 1ë²ˆ ì‹¤í–‰ (ëŒ€ì…)
    for num in arr:  # n+1ë²ˆ ì‹¤í–‰ (ë¹„êµ)
        total += num  # në²ˆ ì‹¤í–‰ (ì—°ì‚°+ëŒ€ì…)
    return total   # 1ë²ˆ ì‹¤í–‰
    # ì´ ì‹œê°„ ë³µì¡ë„: 2n + 3 â†’ O(n)
```

> [!example] Statement Step ë¶„ì„í‘œ
> | Statement | S/E | Frequency | Total Steps |
> |-----------|-----|-----------|-------------|
> | `total = 0` | 1 | 1 | 1 |
> | `for num in arr` | 1 | n+1 | n+1 |
> | `total += num` | 1 | n | n |
> | `return total` | 1 | 1 | 1 |
> | **Total** | | | **2n+3** |

### nì´ ì¶©ë¶„íˆ í´ ë•Œì˜ ì„±ëŠ¥

> [!tip] ì™œ í° ì…ë ¥ê°’ì´ ì¤‘ìš”í•œê°€?
> - ì‘ì€ ì…ë ¥: ëª¨ë“  ì•Œê³ ë¦¬ì¦˜ì´ ë¹ ë¦„ (ì°¨ì´ ë¯¸ë¯¸)
> - í° ì…ë ¥: ì•Œê³ ë¦¬ì¦˜ ê°„ ì„±ëŠ¥ ì°¨ì´ê°€ ê·¹ëª…í•˜ê²Œ ë“œëŸ¬ë‚¨
> - ì˜ˆ: n=10 â†’ O(nÂ²)ê³¼ O(n log n) ì°¨ì´ ì‘ìŒ
> - ì˜ˆ: n=1,000,000 â†’ O(nÂ²)ì€ 1ì¡°ë²ˆ, O(n log n)ì€ ì•½ 2ì²œë§Œë²ˆ (50,000ë°° ì°¨ì´!)

---

## ğŸ“ˆ Asymptotic Notations (ì ê·¼ í‘œê¸°ë²•)

> [!important] ì„¸ ê°€ì§€ ì ê·¼ í‘œê¸°ë²•
> - **Big O (O)**: ìƒí•œì„ (Upper Bound) - ìµœì•…ì˜ ê²½ìš°
> - **Omega (Î©)**: í•˜í•œì„ (Lower Bound) - ìµœì„ ì˜ ê²½ìš°  
> - **Theta (Î˜)**: ìƒí•œì„ ê³¼ í•˜í•œì„ ì„ ë™ì‹œì— ê·œì •(Tight Bound) - í‰ê· ì˜ ê²½ìš°

### í‘œê¸°ë²• ë¹„êµ

```
f(n) = O(g(n))  â†’ f(n) â‰¤ cÂ·g(n) (ìƒí•œì„ )
f(n) = Î©(g(n))  â†’ f(n) â‰¥ cÂ·g(n) (í•˜í•œì„ )
f(n) = Î˜(g(n))  â†’ câ‚Â·g(n) â‰¤ f(n) â‰¤ câ‚‚Â·g(n) (ìƒí•œì„ ê³¼ í•˜í•œì„ )
```

> [!example] ì˜ˆì‹œ: ì„ í˜• íƒìƒ‰
> - **Best Case (Î©)**: Î©(1) - ì²« ë²ˆì§¸ ì›ì†Œê°€ íƒ€ê²Ÿ
> - **Average Case (Î˜)**: Î˜(n/2) â†’ Î˜(n) - ì¤‘ê°„ì¯¤ì—ì„œ ë°œê²¬
> - **Worst Case (O)**: O(n) - ë§ˆì§€ë§‰ ì›ì†Œê°€ íƒ€ê²Ÿ ë˜ëŠ” ì—†ìŒ

---

## ğŸ”€ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ ë³µì¡ë„ ë¹„êµ

> [!info] ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ ì„±ëŠ¥ ë¹„êµí‘œ
> ë‹¤ì–‘í•œ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì˜ ì‹œê°„ ë³µì¡ë„ì™€ ê³µê°„ ë³µì¡ë„ë¥¼ ë¹„êµí•©ë‹ˆë‹¤.

### ì£¼ìš” ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ ë³µì¡ë„

| ì•Œê³ ë¦¬ì¦˜ | Best Case | Average Case | Worst Case | ê³µê°„ ë³µì¡ë„ | ì•ˆì •ì„± |
|---------|-----------|--------------|------------|------------|--------|
| **Bubble Sort** | O(n) | O(nÂ²) | O(nÂ²) | O(1) | ì•ˆì • |
| **Selection Sort** | O(nÂ²) | O(nÂ²) | O(nÂ²) | O(1) | ë¶ˆì•ˆì • |
| **Insertion Sort** | O(n) | O(nÂ²) | O(nÂ²) | O(1) | ì•ˆì • |
| **Merge Sort** | O(n log n) | O(n log n) | O(n log n) | O(n) | ì•ˆì • |
| **Quick Sort** | O(n log n) | O(n log n) | O(nÂ²) | O(log n) | ë¶ˆì•ˆì • |
| **Heap Sort** | O(n log n) | O(n log n) | O(n log n) | O(1) | ë¶ˆì•ˆì • |
| **Counting Sort** | O(n+k) | O(n+k) | O(n+k) | O(k) | ì•ˆì • |
| **Radix Sort** | O(nk) | O(nk) | O(nk) | O(n+k) | ì•ˆì • |
| **Bucket Sort** | O(n+k) | O(n+k) | O(nÂ²) | O(n) | ì•ˆì • |

> [!tip] ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ ì„ íƒ ê°€ì´ë“œ
> - **ì‘ì€ ë°ì´í„°(n < 50)**: Insertion Sort (êµ¬í˜„ ê°„ë‹¨, ì‘ì€ nì—ì„œ ë¹ ë¦„)
> - **ì¼ë°˜ì ì¸ ê²½ìš°**: Quick Sort (í‰ê· ì ìœ¼ë¡œ ê°€ì¥ ë¹ ë¦„)
> - **ìµœì•…ì˜ ê²½ìš°ë„ ë³´ì¥**: Merge Sort, Heap Sort (í•­ìƒ O(n log n))
> - **ì •ìˆ˜ ë°ì´í„°**: Counting Sort, Radix Sort (ì„ í˜• ì‹œê°„)
> - **ê±°ì˜ ì •ë ¬ëœ ë°ì´í„°**: Insertion Sort, Bubble Sort (O(n)ì— ê°€ê¹Œì›€)
> - **ë©”ëª¨ë¦¬ ì œì•½**: Heap Sort, Quick Sort (in-place ì •ë ¬)

### ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ íŠ¹ì„±

> [!note] ì•ˆì •ì„±(Stability)ì´ë€?
> ë™ì¼í•œ ê°’ì„ ê°€ì§„ ì›ì†Œë“¤ì˜ ìƒëŒ€ì  ìˆœì„œê°€ ì •ë ¬ í›„ì—ë„ ìœ ì§€ë˜ëŠ” ì„±ì§ˆ
> - ì•ˆì • ì •ë ¬: Merge Sort, Bubble Sort, Insertion Sort
> - ë¶ˆì•ˆì • ì •ë ¬: Quick Sort, Heap Sort, Selection Sort

---

## ğŸ”¢ ì¬ê·€ ê´€ê³„ì‹ê³¼ ì í™”ì‹

### ì¬ê·€ ì‘ì„±ì˜ 2ê°€ì§€ í•µì‹¬ ìš”ì†Œ

1. **ì´ˆê¸° ì¡°ê±´(Base Case)**: ì¬ê·€ë¥¼ ë©ˆì¶”ëŠ” ì¡°ê±´
2. **ë°˜ë³µ ì¡°ê±´(Recursive Case)**: ë¬¸ì œë¥¼ ë” ì‘ì€ ë¶€ë¶„ìœ¼ë¡œ ë‚˜ëˆ„ëŠ” ë°©ë²•

> [!info] ì í™”ì‹ê³¼ ì¬ê·€ ê´€ê³„
> ì¬ê·€ ì•Œê³ ë¦¬ì¦˜ì˜ ì‹œê°„ ë³µì¡ë„ëŠ” ì í™”ì‹(Recurrence Relation)ìœ¼ë¡œ í‘œí˜„ë©ë‹ˆë‹¤.
> 
> **ì¼ë°˜ í˜•íƒœ**: T(n) = aÂ·T(n/b) + f(n)
> - a: ì¬ê·€ í˜¸ì¶œ íšŸìˆ˜
> - n/b: ë¶€ë¶„ ë¬¸ì œì˜ í¬ê¸°
> - f(n): ë¶„í• /ë³‘í•©ì— ë“œëŠ” ë¹„ìš©

### ì¬ê·€ íŒ¨í„´ë³„ ë³µì¡ë„ ì˜ˆì œ

> [!example] íŒ©í† ë¦¬ì–¼ ì¬ê·€ ë¶„ì„
> ```python
> def factorial(n):
>     if n <= 1:        # ì´ˆê¸° ì¡°ê±´
>         return 1
>     return n * factorial(n-1)  # ë°˜ë³µ ì¡°ê±´
> 
> # T(n) = T(n-1) + O(1)
> # = T(n-2) + O(1) + O(1)
> # = T(n-3) + O(1) + O(1) + O(1)
> # ...
> # = T(1) + (n-1)Â·O(1)
> # = O(n)
> ```

### í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´ ë³µì¡ë„ ë¶„ì„

> [!warning] ë‹¨ìˆœ ì¬ê·€ì˜ ë¹„íš¨ìœ¨ì„±
> ```python
> def fibonacci(n):
>     if n <= 1:
>         return n
>     return fibonacci(n-1) + fibonacci(n-2)
> 
> # T(n) = T(n-1) + T(n-2) + O(1)
> # ê° ë ˆë²¨ì—ì„œ í˜¸ì¶œ ìˆ˜ê°€ 2ë°°ì”© ì¦ê°€
> # â†’ O(2â¿) ì‹œê°„ ë³µì¡ë„
> ```

**ì¬ê·€ íŠ¸ë¦¬ ë¶„ì„**:
```
        F(5)
       /    \
     F(4)    F(3)     â†’ 2ê°œ í˜¸ì¶œ
    /   \    /   \
  F(3) F(2) F(2) F(1) â†’ 4ê°œ í˜¸ì¶œ
  ...                 â†’ 8ê°œ í˜¸ì¶œ
```

> [!tip] ì í™”ì‹ í•´ê²° ë°©ë²•
> - **ë°˜ë³µ ì¡°ê±´ ë‚´ì—ì„œ ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜ì˜ ì‹œê°„ ë³µì¡ë„**ê°€ ì¬ê·€ í•¨ìˆ˜ ì„±ëŠ¥ì— ê°€ì¥ í° ì˜í–¥
> - ë°˜ë³µë˜ëŠ” íšŸìˆ˜ Ã— ë°˜ë³µì¡°ê±´ ë‚´ í•¨ìˆ˜ ì‹œê°„ë³µì¡ë„
> - ìˆ˜í•™ì—ì„œ ì í™”ì‹ì„ ìƒê°í•˜ë©´ ì´í•´ê°€ ì‰½ìŠµë‹ˆë‹¤