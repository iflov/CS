---
tags:
- terraform
- security
- vault
- secrets
- advanced
created: 2025-01-15
updated: 2025-01-15
aliases:
- Terraform Security
- 테라폼 보안
description: Terraform에서 민감한 데이터를 안전하게 관리하는 방법과 보안 베스트 프랙티스
status: published
category: guide
---

# Terraform 보안

> [!info] 개요
> Terraform으로 인프라를 관리할 때 비밀번호, API 키, 인증서 등 민감한 데이터를 안전하게 다루는 것은 매우 중요합니다. 이 가이드에서는 Terraform의 보안 기능과 HashiCorp Vault 연동, 그리고 보안 베스트 프랙티스를 다룹니다.

## 📑 목차

- [[#🔐 민감한 데이터 관리]]
- [[#🛡️ Sensitive 변수]]
- [[#🔑 Vault 통합]]
- [[#📝 State 파일 보안]]
- [[#🔒 Provider 인증 보안]]
- [[#🚨 보안 스캐닝]]
- [[#📋 컴플라이언스]]
- [[#💡 실전 보안 패턴]]
- [[#✨ 보안 체크리스트]]
- [[#📚 참고자료]]

---

## 🔐 민감한 데이터 관리

### 민감한 데이터의 종류

> [!warning] 보호해야 할 데이터
> - **인증 정보**: 패스워드, API 키, 토큰
> - **인증서**: SSL/TLS 인증서, SSH 키
> - **연결 문자열**: 데이터베이스 연결 정보
> - **개인정보**: 이메일, 전화번호 등
> - **비즈니스 민감 정보**: 내부 IP, 도메인 정보

### 환경변수 활용

> [!tip] 환경변수로 민감한 값 전달
> ```bash
> # 환경변수 설정
> export TF_VAR_db_password="SecurePassword123!"
> export TF_VAR_api_key="sk-abc123xyz789"
> 
> # .env 파일 사용 (gitignore에 추가)
> # .env
> TF_VAR_db_password=SecurePassword123!
> TF_VAR_api_key=sk-abc123xyz789
> 
> # 환경변수 로드 후 Terraform 실행
> source .env
> terraform apply
> ```

---

## 🛡️ Sensitive 변수

### Sensitive 플래그 사용

> [!example] 민감한 변수 보호
> ```hcl
> # variables.tf
> variable "db_password" {
>   description = "Database password"
>   type        = string
>   sensitive   = true  # 출력에서 마스킹
> }
> 
> variable "api_keys" {
>   description = "API keys for services"
>   type = map(string)
>   sensitive = true
>   
>   default = {}
> }
> 
> variable "ssh_private_key" {
>   description = "SSH private key"
>   type        = string
>   sensitive   = true
> }
> ```

### Sensitive 출력 처리

> [!warning] 민감한 출력 관리
> ```hcl
> # outputs.tf
> output "db_connection_string" {
>   value = "postgresql://${var.db_user}:${var.db_password}@${aws_db_instance.main.endpoint}/mydb"
>   sensitive = true  # 출력 마스킹
> }
> 
> # 민감한 값 포함된 출력
> output "config" {
>   value = {
>     endpoint = aws_db_instance.main.endpoint
>     username = var.db_user
>     # password는 포함하지 않음
>   }
>   description = "Database configuration (password excluded)"
> }
> 
> # 조건부 민감 정보 노출
> output "debug_info" {
>   value = var.environment == "dev" ? {
>     db_password = var.db_password
>     api_key     = var.api_key
>   } : {}
>   sensitive = true
> }
> ```

### Sensitive 함수 활용

```hcl
# nonsensitive 함수로 명시적 노출 (주의!)
output "exposed_value" {
  value = nonsensitive(var.sensitive_data)
  # 매우 주의해서 사용
}

# sensitive 함수로 동적 보호
locals {
  connection_string = sensitive(
    "Server=${var.server};Database=${var.database};User=${var.user};Password=${var.password}"
  )
}
```

---

## 🔑 Vault 통합

### Vault Provider 설정

> [!example] HashiCorp Vault 연동
> ```hcl
> # Provider 설정
> provider "vault" {
>   address = "https://vault.example.com:8200"
>   
>   # 인증 방법들
>   # 1. Token
>   token = var.vault_token
>   
>   # 2. AppRole
>   auth_login {
>     path = "auth/approle/login"
>     
>     parameters = {
>       role_id   = var.role_id
>       secret_id = var.secret_id
>     }
>   }
> }
> 
> # Vault에서 시크릿 읽기
> data "vault_generic_secret" "database" {
>   path = "secret/data/database/prod"
> }
> 
> # Vault 시크릿 사용
> resource "aws_db_instance" "main" {
>   engine     = "postgres"
>   db_name    = "myapp"
>   
>   username = data.vault_generic_secret.database.data["username"]
>   password = data.vault_generic_secret.database.data["password"]
> }
> ```

### 동적 시크릿 생성

> [!tip] Vault 동적 자격증명
> ```hcl
> # AWS 동적 자격증명
> data "vault_aws_access_credentials" "creds" {
>   backend = "aws"
>   role    = "terraform-role"
>   type    = "sts"
> }
> 
> provider "aws" {
>   access_key = data.vault_aws_access_credentials.creds.access_key
>   secret_key = data.vault_aws_access_credentials.creds.secret_key
>   token      = data.vault_aws_access_credentials.creds.security_token
> }
> 
> # 데이터베이스 동적 자격증명
> data "vault_database_credentials" "db" {
>   backend = "database"
>   role    = "readonly"
> }
> 
> resource "null_resource" "db_connection" {
>   provisioner "local-exec" {
>     command = "psql -U ${data.vault_database_credentials.db.username} -h ${var.db_host}"
>     environment = {
>       PGPASSWORD = data.vault_database_credentials.db.password
>     }
>   }
> }
> ```

### PKI 인증서 관리

```hcl
# Vault PKI 백엔드에서 인증서 발급
resource "vault_pki_secret_backend_cert" "app" {
  backend = vault_mount.pki.path
  name    = vault_pki_secret_backend_role.role.name
  
  common_name = "app.example.com"
  alt_names   = ["app.example.com", "www.app.example.com"]
  
  ttl = "720h"  # 30 days
  
  auto_renew = true
  min_seconds_remaining = 604800  # 7 days
}

# 인증서 사용
resource "aws_acm_certificate" "cert" {
  private_key       = vault_pki_secret_backend_cert.app.private_key
  certificate_body  = vault_pki_secret_backend_cert.app.certificate
  certificate_chain = vault_pki_secret_backend_cert.app.ca_chain
}
```

---

## 📝 State 파일 보안

### State 암호화

> [!danger] State 파일 보호 중요성
> State 파일에는 민감한 정보가 평문으로 저장될 수 있습니다!

```hcl
# S3 Backend with 암호화
terraform {
  backend "s3" {
    bucket = "terraform-state-bucket"
    key    = "prod/terraform.tfstate"
    region = "us-west-2"
    
    # 서버 사이드 암호화
    encrypt = true
    kms_key_id = "arn:aws:kms:us-west-2:123456789012:key/abc-123"
    
    # State 잠금
    dynamodb_table = "terraform-state-lock"
    
    # 액세스 로깅
    logging {
      target_bucket = "terraform-state-logs"
      target_prefix = "state-access-logs/"
    }
  }
}
```

### State 파일 액세스 제어

> [!tip] IAM 정책으로 State 보호
> ```json
> {
>   "Version": "2012-10-17",
>   "Statement": [
>     {
>       "Effect": "Allow",
>       "Principal": {
>         "AWS": "arn:aws:iam::123456789012:role/TerraformRole"
>       },
>       "Action": [
>         "s3:GetObject",
>         "s3:PutObject"
>       ],
>       "Resource": "arn:aws:s3:::terraform-state-bucket/*",
>       "Condition": {
>         "StringEquals": {
>           "s3:x-amz-server-side-encryption": "aws:kms",
>           "s3:x-amz-server-side-encryption-aws-kms-key-id": "arn:aws:kms:us-west-2:123456789012:key/abc-123"
>         }
>       }
>     }
>   ]
> }
> ```

### State에서 민감한 데이터 제거

```hcl
# lifecycle로 State 업데이트 방지
resource "aws_db_instance" "main" {
  # ...
  password = var.db_password
  
  lifecycle {
    ignore_changes = [password]  # State에서 패스워드 변경 무시
  }
}

# 또는 외부에서 패스워드 설정
resource "aws_db_instance" "main" {
  # ...
  # password는 Terraform 외부에서 설정
}

resource "null_resource" "set_db_password" {
  provisioner "local-exec" {
    command = "aws rds modify-db-instance --db-instance-identifier ${aws_db_instance.main.id} --master-user-password ${var.db_password}"
  }
  
  depends_on = [aws_db_instance.main]
}
```

---

## 🔒 Provider 인증 보안

### AWS Provider 보안

> [!example] IAM Role 사용
> ```hcl
> # EC2 Instance Profile 사용 (권장)
> provider "aws" {
>   region = "us-west-2"
>   # 자격증명 명시하지 않음 - Instance Profile 자동 사용
> }
> 
> # AssumeRole로 권한 제한
> provider "aws" {
>   alias  = "prod"
>   region = "us-west-2"
>   
>   assume_role {
>     role_arn     = "arn:aws:iam::123456789012:role/TerraformProdRole"
>     session_name = "TerraformSession"
>     
>     external_id = var.external_id  # 추가 보안
>     
>     policy = jsonencode({
>       Version = "2012-10-17"
>       Statement = [{
>         Effect = "Allow"
>         Action = [
>           "ec2:*",
>           "s3:*"
>         ]
>         Resource = "*"
>       }]
>     })
>   }
> }
> ```

### 임시 자격증명 사용

```hcl
# AWS STS 임시 자격증명
data "aws_caller_identity" "current" {}

resource "aws_iam_role" "temp" {
  name = "terraform-temp-role-${data.aws_caller_identity.current.account_id}"
  
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Action = "sts:AssumeRole"
      Effect = "Allow"
      Principal = {
        AWS = data.aws_caller_identity.current.arn
      }
      Condition = {
        StringEquals = {
          "sts:ExternalId" = random_uuid.external_id.result
        }
      }
    }]
  })
  
  max_session_duration = 3600  # 1시간
}

resource "random_uuid" "external_id" {}
```

---

## 🚨 보안 스캐닝

### tfsec 사용

> [!tip] 정적 보안 분석
> ```bash
> # tfsec 설치
> brew install tfsec
> 
> # 보안 스캔 실행
> tfsec .
> 
> # 특정 체크 무시
> resource "aws_s3_bucket" "example" {
>   bucket = "my-bucket"
>   
>   #tfsec:ignore:aws-s3-enable-versioning
>   versioning {
>     enabled = false
>   }
> }
> 
> # CI/CD에 통합
> # .github/workflows/security.yml
> name: Security Scan
> on: [push, pull_request]
> 
> jobs:
>   tfsec:
>     runs-on: ubuntu-latest
>     steps:
>       - uses: actions/checkout@v2
>       - name: Run tfsec
>         uses: aquasecurity/tfsec-action@v1.0.0
> ```

### Checkov 사용

```bash
# Checkov 설치
pip install checkov

# 스캔 실행
checkov -d .

# 특정 정책 건너뛰기
# CKV_AWS_20: S3 Bucket Public Access
resource "aws_s3_bucket_public_access_block" "example" {
  # checkov:skip=CKV_AWS_20: Public access needed for website
  bucket = aws_s3_bucket.example.id
  
  block_public_acls   = false
  block_public_policy = false
}
```

---

## 📋 컴플라이언스

### Policy as Code

> [!example] Sentinel 정책 (Terraform Cloud)
> ```hcl
> # sentinel.hcl
> policy "enforce-encryption" {
>   enforcement_level = "hard-mandatory"
> }
> 
> policy "restrict-instance-types" {
>   enforcement_level = "soft-mandatory"
> }
> ```
> 
> ```python
> # enforce-encryption.sentinel
> import "tfplan/v2" as tfplan
> 
> # 모든 S3 버킷은 암호화되어야 함
> s3_buckets = filter tfplan.resource_changes as _, rc {
>   rc.type is "aws_s3_bucket" and
>   rc.mode is "managed" and
>   rc.change.actions contains "create"
> }
> 
> violations = filter s3_buckets as _, bucket {
>   bucket.change.after.server_side_encryption_configuration is empty
> }
> 
> main = rule {
>   length(violations) is 0
> }
> ```

### Open Policy Agent (OPA)

```rego
# terraform.rego
package terraform.security

deny[msg] {
  resource := input.resource_changes[_]
  resource.type == "aws_security_group_rule"
  resource.change.after.cidr_blocks[_] == "0.0.0.0/0"
  resource.change.after.from_port == 22
  
  msg := sprintf("SSH access from 0.0.0.0/0 is not allowed: %v", [resource.address])
}

deny[msg] {
  resource := input.resource_changes[_]
  resource.type == "aws_db_instance"
  resource.change.after.publicly_accessible == true
  
  msg := sprintf("Database must not be publicly accessible: %v", [resource.address])
}
```

---

## 💡 실전 보안 패턴

### 시크릿 로테이션

> [!example] 자동 패스워드 로테이션
> ```hcl
> # 랜덤 패스워드 생성
> resource "random_password" "db" {
>   length  = 32
>   special = true
>   
>   keepers = {
>     # 매달 패스워드 로테이션
>     rotation = formatdate("YYYY-MM", timestamp())
>   }
> }
> 
> # Secrets Manager에 저장
> resource "aws_secretsmanager_secret" "db_password" {
>   name = "rds-password-${var.environment}"
>   
>   rotation_rules {
>     automatically_after_days = 30
>   }
> }
> 
> resource "aws_secretsmanager_secret_version" "db_password" {
>   secret_id     = aws_secretsmanager_secret.db_password.id
>   secret_string = random_password.db.result
> }
> 
> # RDS에서 Secrets Manager 사용
> resource "aws_db_instance" "main" {
>   # ...
>   manage_master_user_password = true
>   master_user_secret_kms_key_id = aws_kms_key.rds.id
> }
> ```

### 최소 권한 원칙

```hcl
# 환경별 권한 분리
locals {
  permissions = {
    dev = [
      "ec2:*",
      "s3:*"
    ]
    staging = [
      "ec2:Describe*",
      "ec2:Create*",
      "s3:Get*",
      "s3:Put*"
    ]
    production = [
      "ec2:DescribeInstances",
      "s3:GetObject"
    ]
  }
}

resource "aws_iam_policy" "terraform" {
  name = "terraform-${var.environment}"
  
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Effect   = "Allow"
      Action   = local.permissions[var.environment]
      Resource = "*"
    }]
  })
}
```

---

## ✨ 보안 체크리스트

> [!success] Terraform 보안 체크리스트
> 
> **코드 보안**
> - [ ] Sensitive 변수 사용
> - [ ] 하드코딩된 시크릿 제거
> - [ ] .gitignore에 민감한 파일 추가
> - [ ] 보안 스캐너 실행 (tfsec, checkov)
> 
> **State 보안**
> - [ ] Remote Backend 사용
> - [ ] State 암호화 활성화
> - [ ] State 액세스 로깅
> - [ ] State 잠금 설정
> 
> **Provider 보안**
> - [ ] IAM Role/Service Principal 사용
> - [ ] 최소 권한 원칙 적용
> - [ ] MFA 활성화
> - [ ] 임시 자격증명 사용
> 
> **시크릿 관리**
> - [ ] Vault/Secrets Manager 통합
> - [ ] 환경변수 사용
> - [ ] 시크릿 로테이션 구현
> - [ ] 키 관리 시스템(KMS) 사용
> 
> **CI/CD 보안**
> - [ ] 보안 스캔 자동화
> - [ ] Pull Request 리뷰 강제
> - [ ] 프로덕션 배포 승인 프로세스
> - [ ] 감사 로그 유지

---

## 📚 참고자료

### 관련 문서
- [[Terraform 기초]]
- [[06. Terraform 상태 관리]]
- [[11. Terraform 프로바이더]]

### 외부 리소스
- [Terraform Security Best Practices](https://www.terraform.io/docs/cloud/guides/recommended-practices/part3.html)
- [tfsec Documentation](https://aquasecurity.github.io/tfsec/)
- [Checkov Documentation](https://www.checkov.io/)
- [HashiCorp Vault](https://www.vaultproject.io/)

---

> [!quote]
> "보안은 기능이 아닌 기본입니다. 처음부터 보안을 고려하여 설계하면, 나중에 수정하는 것보다 훨씬 효과적입니다."