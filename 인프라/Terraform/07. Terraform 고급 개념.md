---
tags:
- terraform
- infrastructure
- iac
- devops
- advanced
created: 2025-01-15
updated: 2025-01-15
aliases:
- Terraform Advanced
- 테라폼 고급
description: Terraform의 고급 기능과 개념을 다루는 종합 가이드
status: published
category: guide
---

# Terraform 고급 개념

> [!info] 개요
> Terraform의 리소스 생명주기 관리, 데이터 소스, Meta-Arguments, 동적 블록 등 고급 기능을 마스터하기 위한 종합 가이드입니다. 실무에서 효율적인 인프라 관리를 위한 필수 개념들을 다룹니다.

## 📑 목차

- [[#🔄 리소스 동작 관리]]
- [[#🛡️ Lifecycle Rules]]
- [[#📊 Data Sources]]
- [[#🔧 Meta-Arguments]]
- [[#📦 버전 관리]]
- [[#🔁 Dynamic Blocks]]
- [[#❓ 조건부 리소스 생성]]
- [[#⚠️ Provisioners (비추천)]]
- [[#✨ Best Practices]]
- [[#📚 참고자료]]

---

## 🔄 리소스 동작 관리

### Mutable vs Immutable Resources

#### Mutable Resources (변경 가능)

> [!note] 변경 가능한 리소스
> 생성 후 수정 가능한 리소스입니다. 속성 변경 시 리소스를 재생성하지 않고 업데이트합니다.

```hcl
# EC2 인스턴스의 태그나 보안 그룹은 변경 가능
resource "aws_instance" "example" {
  # 이 속성들은 변경 가능
  tags = {
    Name = "MyInstance"
    Environment = "Dev"  # Prod로 변경 가능
  }
  
  security_groups = ["sg-123456"]  # 업데이트 가능
}
```

> [!example] Mutable 속성 예시
> - **EC2**: 태그, 보안 그룹, IAM 역할
> - **RDS**: 백업 설정, 유지 관리 윈도우
> - **S3**: 버킷 정책, 라이프사이클 규칙

#### Immutable Resources (변경 불가)

> [!warning] 변경 불가능한 리소스
> 생성 후 수정할 수 없어 변경 시 리소스 재생성이 필요합니다.

```hcl
# S3 버킷 이름이나 암호화 설정은 변경 불가
resource "aws_s3_bucket" "example" {
  # 이 속성들은 변경 시 리소스 재생성 필요
  bucket = "my-unique-bucket-name"  # 변경 불가
  
  # 암호화 설정 변경 시 버킷 재생성 필요
  server_side_encryption_configuration {
    rule {
      apply_server_side_encryption_by_default {
        sse_algorithm = "AES256"  # KMS로 변경 시 재생성
      }
    }
  }
}
```

> [!example] Immutable 속성 예시
> - **S3**: 버킷 이름, 리전, 암호화 타입
> - **EC2**: AMI ID, 인스턴스 타입 (일부)
> - **RDS**: 엔진 타입, 마스터 사용자명

---

## 🛡️ Lifecycle Rules

> [!tip] Lifecycle Rules 활용
> 리소스 생명주기 동작을 세밀하게 제어하여 안전한 인프라 변경을 가능하게 합니다.

### create_before_destroy

> [!note] 무중단 교체
> 기존 리소스 삭제 전 새 리소스를 먼저 생성합니다.

```hcl
resource "aws_instance" "example" {
  ami           = "ami-123456"
  instance_type = "t2.micro"
  
  lifecycle {
    create_before_destroy = true
  }
}
```

**사용 사례:**
- 무중단 배포 필요 시
- 로드 밸런서 대상 그룹
- DNS 레코드 변경

### prevent_destroy

> [!danger] 삭제 방지
> 실수로 리소스가 삭제되는 것을 방지합니다.

```hcl
resource "aws_rds_instance" "database" {
  identifier = "prod-database"
  # ... 기타 설정
  
  lifecycle {
    prevent_destroy = true
  }
}
```

**사용 사례:**
- 프로덕션 데이터베이스
- 중요한 S3 버킷
- 핵심 네트워크 리소스

### ignore_changes

> [!tip] 변경 무시
> 외부에서 수정된 특정 속성 변경을 무시합니다.

```hcl
resource "aws_instance" "example" {
  ami           = "ami-123456"
  instance_type = "t2.micro"
  
  tags = {
    Name = "MyInstance"
    ManagedBy = "Terraform"
  }
  
  lifecycle {
    ignore_changes = [tags]  # 태그 변경 무시
    # 또는 특정 태그만
    # ignore_changes = [tags["Environment"]]
  }
}
```

**사용 사례:**
- 외부 시스템이 수정하는 속성
- Auto Scaling이 관리하는 속성
- 수동으로 관리되는 태그

### replace_triggered_by

> [!note] 연쇄 교체
> 다른 리소스 변경 시 자동으로 재생성을 트리거합니다.

```hcl
resource "aws_instance" "example" {
  # ... 인스턴스 설정
  
  lifecycle {
    replace_triggered_by = [
      aws_s3_object.config.etag
    ]
  }
}
```

---

## 📊 Data Sources

> [!info] Data Sources란?
> Terraform이 직접 관리하지 않는 외부 리소스의 정보를 조회하고 참조할 수 있게 해주는 기능입니다.

### 기본 사용법

```hcl
# 기존 VPC 정보 조회
data "aws_vpc" "existing" {
  tags = {
    Name = "production-vpc"
  }
}

# 조회한 정보 사용
resource "aws_subnet" "example" {
  vpc_id = data.aws_vpc.existing.id
  # ...
}
```

### 실용적인 예시

#### 최신 AMI 조회

> [!example] Amazon Linux 최신 버전 자동 조회
> ```hcl
> data "aws_ami" "latest_amazon_linux" {
>   most_recent = true
>   owners      = ["amazon"]
>   
>   filter {
>     name   = "name"
>     values = ["amzn2-ami-hvm-*-x86_64-gp2"]
>   }
>   
>   filter {
>     name   = "virtualization-type"
>     values = ["hvm"]
>   }
> }
> 
> resource "aws_instance" "example" {
>   ami = data.aws_ami.latest_amazon_linux.id
>   # ...
> }
> ```

#### 기존 파일 읽기

```hcl
data "local_file" "config" {
  filename = "${path.module}/config.json"
}

locals {
  config = jsondecode(data.local_file.config.content)
}
```

#### AWS 계정 정보

```hcl
data "aws_caller_identity" "current" {}

output "account_id" {
  value = data.aws_caller_identity.current.account_id
}
```

---

## 🔧 Meta-Arguments

> [!note] Meta-Arguments
> 모든 리소스와 데이터 소스에서 사용 가능한 특별한 인자들입니다.

### depends_on

> [!tip] 명시적 의존성
> 암시적 의존성이 충분하지 않을 때 명시적으로 의존성을 지정합니다.

```hcl
resource "aws_iam_role" "example" {
  # ...
}

resource "aws_iam_role_policy" "example" {
  role = aws_iam_role.example.id
  # ...
  
  depends_on = [
    aws_iam_role.example
  ]
}
```

### count

> [!example] 동일한 리소스 여러 개 생성
> ```hcl
> variable "instance_count" {
>   default = 3
> }
> 
> resource "aws_instance" "server" {
>   count = var.instance_count
>   
>   ami           = "ami-123456"
>   instance_type = "t2.micro"
>   
>   tags = {
>     Name = "Server-${count.index}"
>   }
> }
> 
> # 참조
> output "instance_ips" {
>   value = aws_instance.server[*].public_ip
> }
> ```

### for_each

> [!tip] 맵/세트 기반 리소스 생성
> count보다 유연하고 관리하기 쉬운 방식입니다.

```hcl
variable "instances" {
  default = {
    web = "t2.micro"
    app = "t2.small"
    db  = "t2.medium"
  }
}

resource "aws_instance" "server" {
  for_each = var.instances
  
  ami           = "ami-123456"
  instance_type = each.value
  
  tags = {
    Name = "Server-${each.key}"
    Type = each.key
  }
}

# 참조
output "web_server_ip" {
  value = aws_instance.server["web"].public_ip
}
```

### provider

> [!example] 멀티 리전 설정
> ```hcl
> provider "aws" {
>   region = "us-west-2"
>   alias  = "west"
> }
> 
> provider "aws" {
>   region = "us-east-1"
>   alias  = "east"
> }
> 
> resource "aws_instance" "west_server" {
>   provider = aws.west
>   # ...
> }
> 
> resource "aws_instance" "east_server" {
>   provider = aws.east
>   # ...
> }
> ```

---

## 📦 버전 관리

### Provider 버전 고정

> [!warning] 버전 관리 중요성
> Provider 버전을 명시하지 않으면 예기치 않은 변경사항이 발생할 수 있습니다.

```hcl
terraform {
  required_version = ">= 1.0"
  
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"  # 5.x 버전만 허용
    }
    
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = ">= 2.0, < 3.0"  # 2.x 버전만
    }
  }
}
```

### 버전 제약 연산자

> [!note] 연산자 설명
> - `=`: 정확한 버전
> - `!=`: 특정 버전 제외
> - `>`, `>=`, `<`, `<=`: 비교 연산자
> - `~>`: 호환 버전 (마지막 숫자만 증가 허용)

```hcl
version = "~> 1.2.0"  # >= 1.2.0, < 1.3.0
version = "~> 1.2"    # >= 1.2.0, < 2.0.0
```

---

## 🔁 Dynamic Blocks

> [!tip] 동적 블록 생성
> 반복적인 중첩 블록을 프로그래밍 방식으로 생성합니다.

```hcl
variable "ingress_rules" {
  default = [
    { port = 80, protocol = "tcp" },
    { port = 443, protocol = "tcp" },
    { port = 22, protocol = "tcp" }
  ]
}

resource "aws_security_group" "example" {
  name = "example"
  
  dynamic "ingress" {
    for_each = var.ingress_rules
    
    content {
      from_port   = ingress.value.port
      to_port     = ingress.value.port
      protocol    = ingress.value.protocol
      cidr_blocks = ["0.0.0.0/0"]
    }
  }
}
```

---

## ❓ 조건부 리소스 생성

> [!example] 조건부 생성 패턴
> ```hcl
> variable "create_instance" {
>   type    = bool
>   default = true
> }
> 
> # count를 사용한 조건부
> resource "aws_instance" "conditional" {
>   count = var.create_instance ? 1 : 0
>   
>   ami           = "ami-123456"
>   instance_type = "t2.micro"
> }
> 
> # for_each를 사용한 조건부
> resource "aws_instance" "conditional_map" {
>   for_each = var.create_instance ? toset(["instance"]) : toset([])
>   
>   ami           = "ami-123456"
>   instance_type = "t2.micro"
> }
> ```

---

## ⚠️ Provisioners (비추천)

> [!danger] Provisioners 사용 주의
> Provisioners는 최후의 수단으로만 사용해야 합니다. 대부분의 경우 더 나은 대안이 존재합니다.

```hcl
resource "aws_instance" "example" {
  # ...
  
  # 로컬에서 실행
  provisioner "local-exec" {
    command = "echo ${self.public_ip} > ip_address.txt"
  }
  
  # 원격에서 실행
  provisioner "remote-exec" {
    inline = [
      "sudo apt-get update",
      "sudo apt-get install -y nginx"
    ]
    
    connection {
      type        = "ssh"
      user        = "ubuntu"
      private_key = file("~/.ssh/id_rsa")
      host        = self.public_ip
    }
  }
}
```

> [!tip] Provisioner 대안
> - **User Data (EC2)**: 인스턴스 초기화 스크립트
> - **Configuration Management Tools**: Ansible, Chef, Puppet
> - **Custom AMI**: 미리 구성된 이미지 사용
> - **Container Images**: Docker 이미지 활용

---

## ✨ Best Practices

> [!success] 핵심 권장사항
> 1. **Lifecycle Rules 신중히 사용**: 의도하지 않은 동작 방지
> 2. **Data Sources 활용**: 기존 리소스 재사용으로 중복 제거
> 3. **for_each 선호**: count보다 관리가 용이하고 예측 가능
> 4. **Dynamic Blocks 적절히 사용**: 과도한 복잡성 방지
> 5. **Provisioners 피하기**: 더 나은 도구와 방법 활용
> 6. **버전 제약 명시**: 예측 가능한 동작 보장
> 7. **Meta-Arguments 이해**: 효율적인 리소스 관리

---

## 📚 참고자료

### 관련 문서
- [[01. Terraform 기초]]
- [[02. Terraform 명령어]]
- [[06. Terraform 상태 관리]]
- [[04. Terraform 변수 (Input Variables)]]
- [[05. Terraform 출력 변수 (Output)]]

### 외부 리소스
- [Terraform 공식 문서 - Lifecycle](https://www.terraform.io/docs/configuration/lifecycle.html)
- [Terraform 공식 문서 - Data Sources](https://www.terraform.io/docs/configuration/data-sources.html)
- [Terraform Best Practices](https://www.terraform-best-practices.com/)

---

> [!quote]
> "인프라를 코드로 관리하는 것은 단순한 자동화를 넘어, 예측 가능하고 재현 가능한 시스템을 구축하는 것입니다." - HashiCorp