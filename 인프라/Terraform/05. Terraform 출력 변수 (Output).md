---
tags:
  - terraform
  - output
  - variables
  - iac
  - tutorial
created: 2025-01-20
updated: 2025-01-20
aliases:
  - Terraform Outputs
  - Output Variables
  - 테라폼 출력
description: Terraform Output Values를 사용하여 리소스 정보를 출력하고 모듈 간 데이터를 전달하는 방법
status: published
category: tutorial
---

# Terraform 출력 변수 (Output)

> [!info] 개요
> Terraform Output Values는 인프라 구성의 결과를 외부로 노출하는 방법입니다. 모듈의 반환 값처럼 작동하며, 다른 구성에서 참조하거나 CI/CD 파이프라인에서 활용할 수 있습니다.

## 📑 목차

- [[#⚡ 빠른 시작]]
- [[#🎯 Output의 역할]]
- [[#📝 Output 정의]]
- [[#🔍 Output 조회]]
- [[#🔗 모듈 간 데이터 전달]]
- [[#💡 고급 패턴]]
- [[#🚀 실전 예제]]
- [[#⚠️ 주의사항]]
- [[#📚 다음 단계]]

---

## ⚡ 빠른 시작

> [!example] 기본 Output 사용법
> EC2 인스턴스의 정보를 출력하는 간단한 예제입니다.

```hcl
# main.tf
resource "aws_instance" "web" {
  ami           = "ami-xxxxxxxxx"
  instance_type = "t2.micro"
}

# outputs.tf
output "instance_id" {
  value = aws_instance.web.id
}

output "public_ip" {
  value = aws_instance.web.public_ip
}

output "web_url" {
  value = "http://${aws_instance.web.public_ip}"
}
```

```bash
# Output 확인
terraform output
terraform output public_ip
```

---

## 🎯 Output의 역할

> [!abstract] 왜 Output을 사용해야 하나요?
> Output은 Terraform 구성의 결과를 활용 가능하게 만듭니다.

### Output 사용 시나리오

| 시나리오 | 설명 | 예시 |
|---------|------|------|
| **정보 표시** | 생성된 리소스 정보 확인 | IP 주소, ID, URL |
| **모듈 반환값** | 모듈에서 값 반환 | VPC ID, Subnet IDs |
| **자동화 통합** | CI/CD 파이프라인 연동 | 배포 URL, 엔드포인트 |
| **Remote State** | 다른 구성에서 참조 | 공유 리소스 정보 |
| **문서화** | 인프라 정보 자동 문서화 | 구성 요약 생성 |

---

## 📝 Output 정의

### 기본 구조

```hcl
output "name" {
  value       = expression
  description = "설명 (선택사항)"
  sensitive   = false
  depends_on  = []
  precondition {
    condition     = expression
    error_message = "오류 메시지"
  }
}
```

### Output 속성

#### value (필수)

출력할 실제 값을 지정합니다.

```hcl
output "simple_value" {
  value = aws_instance.example.id
}

output "computed_value" {
  value = "Instance ${aws_instance.example.id} is ready at ${aws_instance.example.public_ip}"
}

output "conditional_value" {
  value = var.create_instance ? aws_instance.example[0].id : null
}
```

#### description (선택)

Output의 목적을 설명합니다.

```hcl
output "database_endpoint" {
  value       = aws_db_instance.main.endpoint
  description = "RDS instance connection endpoint"
}
```

#### sensitive (선택)

민감한 정보를 마스킹합니다.

```hcl
output "database_password" {
  value     = random_password.db.result
  sensitive = true
  description = "Database master password (sensitive)"
}

# 출력 시 표시
# database_password = <sensitive>
```

#### depends_on (선택)

명시적 의존성을 설정합니다.

```hcl
output "api_endpoint" {
  value = aws_api_gateway_deployment.main.invoke_url
  
  depends_on = [
    aws_api_gateway_integration.lambda
  ]
}
```

#### precondition (선택)

> [!tip] Terraform 1.2+
> precondition은 Terraform 1.2 이상에서 사용 가능합니다.

```hcl
output "load_balancer_dns" {
  value = aws_lb.main.dns_name
  
  precondition {
    condition     = aws_lb.main.internal == false
    error_message = "Load balancer must be internet-facing."
  }
}
```

---

## 🔍 Output 조회

### CLI 명령어

```bash
# 모든 Output 조회
terraform output

# 특정 Output 조회
terraform output instance_id

# JSON 형식으로 조회
terraform output -json

# Raw 값만 조회 (스크립트에 유용)
terraform output -raw instance_id
```

### 출력 형식 예제

> [!example] 다양한 출력 형식

```bash
# 기본 출력
$ terraform output
instance_id = "i-1234567890abcdef0"
public_ip = "54.123.45.67"
private_ips = [
  "10.0.1.10",
  "10.0.2.20",
]

# JSON 출력
$ terraform output -json
{
  "instance_id": {
    "sensitive": false,
    "type": "string",
    "value": "i-1234567890abcdef0"
  },
  "public_ip": {
    "sensitive": false,
    "type": "string",
    "value": "54.123.45.67"
  }
}

# Raw 출력 (스크립트용)
$ terraform output -raw public_ip
54.123.45.67
```

### 스크립트에서 활용

```bash
#!/bin/bash
# deploy.sh

# Terraform 적용
terraform apply -auto-approve

# Output 값을 변수로 저장
INSTANCE_IP=$(terraform output -raw public_ip)
API_ENDPOINT=$(terraform output -raw api_endpoint)

# SSH 접속
ssh -i key.pem ubuntu@$INSTANCE_IP

# API 테스트
curl $API_ENDPOINT/health

# 환경 변수로 내보내기
export APP_URL=$(terraform output -raw app_url)
```

---

## 🔗 모듈 간 데이터 전달

### 모듈 Output 정의

> [!note] 모듈의 반환값
> 모듈은 Output을 통해 값을 반환합니다.

#### modules/network/outputs.tf

```hcl
output "vpc_id" {
  value       = aws_vpc.main.id
  description = "The ID of the VPC"
}

output "public_subnet_ids" {
  value       = aws_subnet.public[*].id
  description = "List of public subnet IDs"
}

output "private_subnet_ids" {
  value       = aws_subnet.private[*].id
  description = "List of private subnet IDs"
}

output "nat_gateway_ips" {
  value       = aws_eip.nat[*].public_ip
  description = "List of NAT Gateway IP addresses"
}

output "network_summary" {
  value = {
    vpc_id             = aws_vpc.main.id
    vpc_cidr           = aws_vpc.main.cidr_block
    availability_zones = aws_subnet.public[*].availability_zone
    public_subnets     = aws_subnet.public[*].id
    private_subnets    = aws_subnet.private[*].id
  }
  description = "Network configuration summary"
}
```

### Root Module에서 모듈 Output 사용

#### main.tf

```hcl
module "network" {
  source = "./modules/network"
  
  vpc_cidr = "10.0.0.0/16"
  az_count = 2
}

module "compute" {
  source = "./modules/compute"
  
  # 네트워크 모듈의 Output 사용
  vpc_id     = module.network.vpc_id
  subnet_ids = module.network.private_subnet_ids
}

# Root 모듈에서 재출력
output "vpc_id" {
  value       = module.network.vpc_id
  description = "VPC ID from network module"
}

output "instance_ips" {
  value       = module.compute.instance_private_ips
  description = "Private IPs from compute module"
}
```

---

## 💡 고급 패턴

### 복잡한 데이터 구조

> [!example] 구조화된 Output
> 관련 정보를 그룹화하여 출력합니다.

```hcl
# 리스트 출력
output "all_instance_ids" {
  value = aws_instance.web[*].id
  description = "All EC2 instance IDs"
}

# 맵 출력
output "instance_details" {
  value = {
    for instance in aws_instance.web:
    instance.id => {
      private_ip = instance.private_ip
      public_ip  = instance.public_ip
      az         = instance.availability_zone
      state      = instance.instance_state
    }
  }
  description = "Detailed information for each instance"
}

# 중첩된 구조
output "infrastructure_summary" {
  value = {
    network = {
      vpc_id          = aws_vpc.main.id
      subnet_count    = length(aws_subnet.all)
      security_groups = aws_security_group.all[*].id
    }
    compute = {
      instance_count = length(aws_instance.all)
      instance_types = distinct(aws_instance.all[*].instance_type)
      total_vcpus    = sum([for i in aws_instance.all : i.vcpu_count])
    }
    storage = {
      s3_buckets = aws_s3_bucket.all[*].id
      ebs_volumes = aws_ebs_volume.all[*].id
      total_size_gb = sum(aws_ebs_volume.all[*].size)
    }
  }
  description = "Complete infrastructure summary"
}
```

### 조건부 Output

```hcl
# 조건부 값
output "bastion_ip" {
  value = var.create_bastion ? aws_instance.bastion[0].public_ip : null
  description = "Bastion host public IP (if created)"
}

# 동적 필터링
output "production_instances" {
  value = [
    for instance in aws_instance.all:
    instance.id
    if instance.tags["Environment"] == "production"
  ]
  description = "Only production instance IDs"
}

# 조건부 맵
output "endpoints" {
  value = {
    web = var.enable_web ? aws_lb.web[0].dns_name : null
    api = var.enable_api ? aws_api_gateway_deployment.api[0].invoke_url : null
    cdn = var.enable_cdn ? aws_cloudfront_distribution.cdn[0].domain_name : null
  }
  description = "Service endpoints (if enabled)"
}
```

### Remote State Data Source

> [!tip] 크로스 스택 참조
> Remote State를 통해 다른 Terraform 구성의 Output을 참조할 수 있습니다.

```hcl
# 네트워크 스택의 Output 참조
data "terraform_remote_state" "network" {
  backend = "s3"
  
  config = {
    bucket = "terraform-state-bucket"
    key    = "network/terraform.tfstate"
    region = "us-west-2"
  }
}

# Remote State Output 사용
resource "aws_instance" "app" {
  subnet_id = data.terraform_remote_state.network.outputs.subnet_ids[0]
  vpc_security_group_ids = [
    data.terraform_remote_state.network.outputs.default_security_group_id
  ]
}
```

---

## 🚀 실전 예제

### CI/CD 파이프라인 통합

> [!example] GitHub Actions와 통합
> Terraform Output을 CI/CD 파이프라인에서 활용하는 예제

#### terraform/outputs.tf

```hcl
output "app_url" {
  value       = aws_lb.app.dns_name
  description = "Application load balancer URL"
}

output "s3_bucket" {
  value       = aws_s3_bucket.static.id
  description = "S3 bucket for static assets"
}

output "cloudfront_distribution" {
  value       = aws_cloudfront_distribution.cdn.domain_name
  description = "CloudFront distribution domain"
}

output "deployment_config" {
  value = {
    region     = var.aws_region
    account_id = data.aws_caller_identity.current.account_id
    app_name   = var.app_name
    environment = var.environment
  }
  description = "Deployment configuration"
}
```

#### .github/workflows/deploy.yml

```yaml
name: Deploy Infrastructure

on:
  push:
    branches: [main]

jobs:
  terraform:
    runs-on: ubuntu-latest
    
    outputs:
      app_url: ${{ steps.output.outputs.app_url }}
      s3_bucket: ${{ steps.output.outputs.s3_bucket }}
      
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_wrapper: false
          
      - name: Terraform Init
        run: terraform init
        working-directory: ./terraform
        
      - name: Terraform Apply
        run: terraform apply -auto-approve
        working-directory: ./terraform
        
      - name: Get Terraform Outputs
        id: output
        run: |
          echo "app_url=$(terraform output -raw app_url)" >> $GITHUB_OUTPUT
          echo "s3_bucket=$(terraform output -raw s3_bucket)" >> $GITHUB_OUTPUT
        working-directory: ./terraform
        
  deploy-app:
    needs: terraform
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Deploy to S3
        run: |
          aws s3 sync ./dist s3://${{ needs.terraform.outputs.s3_bucket }}
          
      - name: Test Deployment
        run: |
          curl -f http://${{ needs.terraform.outputs.app_url }}/health
          
      - name: Notify Slack
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "Deployment complete!",
              "blocks": [{
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "✅ *Deployment Successful*\n• URL: ${{ needs.terraform.outputs.app_url }}\n• Bucket: ${{ needs.terraform.outputs.s3_bucket }}"
                }
              }]
            }
```

### 문서 자동 생성

> [!example] Markdown 문서 생성
> Output을 사용하여 인프라 문서를 자동으로 생성합니다.

```hcl
output "infrastructure_documentation" {
  value = <<-EOT
    # Infrastructure Documentation
    
    Generated: ${timestamp()}
    
    ## Network Configuration
    - VPC ID: ${aws_vpc.main.id}
    - VPC CIDR: ${aws_vpc.main.cidr_block}
    - Public Subnets: ${join(", ", aws_subnet.public[*].id)}
    - Private Subnets: ${join(", ", aws_subnet.private[*].id)}
    
    ## Compute Resources
    - Instance Count: ${length(aws_instance.all)}
    - Instance Types: ${join(", ", distinct(aws_instance.all[*].instance_type))}
    - Load Balancer: ${aws_lb.main.dns_name}
    
    ## Database
    - Endpoint: ${aws_db_instance.main.endpoint}
    - Engine: ${aws_db_instance.main.engine} ${aws_db_instance.main.engine_version}
    - Instance Class: ${aws_db_instance.main.instance_class}
    
    ## Storage
    - S3 Buckets: ${join(", ", aws_s3_bucket.all[*].id)}
    - Total EBS Volume Size: ${sum(aws_ebs_volume.all[*].size)} GB
    
    ## Access Points
    - Web Application: https://${aws_lb.main.dns_name}
    - API Endpoint: ${aws_api_gateway_deployment.api.invoke_url}
    - CDN: https://${aws_cloudfront_distribution.cdn.domain_name}
    
    ## Security
    - WAF Enabled: ${aws_wafv2_web_acl.main.id != "" ? "Yes" : "No"}
    - SSL Certificate: ${aws_acm_certificate.main.domain_name}
    
    ## Tags
    - Environment: ${var.environment}
    - Project: ${var.project_name}
    - Cost Center: ${var.cost_center}
  EOT
  
  description = "Auto-generated infrastructure documentation"
}

# 문서를 파일로 저장
resource "local_file" "documentation" {
  content  = output.infrastructure_documentation.value
  filename = "${path.module}/INFRASTRUCTURE.md"
}
```

### 모니터링 설정 출력

```hcl
output "monitoring_config" {
  value = {
    cloudwatch = {
      log_groups = aws_cloudwatch_log_group.all[*].name
      dashboards = aws_cloudwatch_dashboard.all[*].dashboard_name
      alarms     = aws_cloudwatch_metric_alarm.all[*].alarm_name
    }
    
    datadog = var.enable_datadog ? {
      api_key    = var.datadog_api_key
      app_key    = var.datadog_app_key
      dashboards = datadog_dashboard.all[*].id
      monitors   = datadog_monitor.all[*].id
    } : null
    
    prometheus = var.enable_prometheus ? {
      endpoint = aws_prometheus_workspace.main.prometheus_endpoint
      grafana  = aws_grafana_workspace.main.endpoint
    } : null
  }
  
  description = "Monitoring configuration for all services"
  sensitive   = true  # API keys 포함
}
```

---

## ⚠️ 주의사항

> [!warning] Output 사용 시 주의점
> 보안과 성능을 고려한 모범 사례입니다.

### 1. 민감한 정보 보호

```hcl
# ❌ 잘못된 예 - 패스워드 노출
output "db_password" {
  value = aws_db_instance.main.password
}

# ✅ 올바른 예 - sensitive 플래그 사용
output "db_password" {
  value     = aws_db_instance.main.password
  sensitive = true
}

# ✅ 더 나은 예 - 필요한 경우만 출력
output "db_connection_string" {
  value = format(
    "postgresql://%s:****@%s/%s",
    aws_db_instance.main.username,
    aws_db_instance.main.endpoint,
    aws_db_instance.main.db_name
  )
  description = "Database connection string (password hidden)"
}
```

### 2. 순환 참조 방지

```hcl
# ❌ 잘못된 예 - 순환 참조
output "self_reference" {
  value = output.self_reference  # 오류!
}

# ✅ 올바른 예
output "instance_info" {
  value = aws_instance.example.id
}
```

### 3. 대용량 출력 주의

```hcl
# ⚠️ 주의 - 매우 큰 출력
output "all_logs" {
  value = data.aws_s3_object.huge_file.body  # 수 MB의 데이터
}

# ✅ 더 나은 방법 - 참조 정보만 출력
output "log_location" {
  value = {
    bucket = data.aws_s3_object.huge_file.bucket
    key    = data.aws_s3_object.huge_file.key
    size   = data.aws_s3_object.huge_file.content_length
  }
}
```

### 4. Output 네이밍 컨벤션

```hcl
# 일관된 네이밍 규칙 사용
output "vpc_id" { }                    # 리소스_속성
output "public_subnet_ids" { }         # 형용사_리소스_ids
output "database_connection_string" { } # 리소스_용도
output "web_application_url" { }       # 서비스_타입_형식
```

---

## 📚 다음 단계

> [!success] 학습 경로
> Output을 마스터했다면 다음 주제로 진행하세요.

### 관련 문서

- [[04. Terraform 변수 (Input Variables)]] - Input과 Output의 관계
- [[Terraform 상태 관리]] - Output과 State
- [[Terraform Provider 관리]] - Provider별 Output 패턴
- [[07. Terraform 고급 개념#Data Sources]] - Remote State 활용

### 실습 과제

1. **기본 실습**: 5개 이상의 Output 정의하고 조회하기
2. **모듈 실습**: 모듈에서 Output 정의하고 사용하기
3. **자동화 실습**: Output을 스크립트에서 활용하기
4. **문서화 실습**: Output으로 인프라 문서 자동 생성하기

### 추가 학습 자료

- [Terraform Output Documentation](https://www.terraform.io/docs/language/values/outputs.html)
- [Output Best Practices](https://www.terraform.io/docs/cloud/guides/recommended-practices/part3.html)
- [[00. Terraform 학습 가이드]] - 전체 학습 로드맵

---

> [!quote]
> "Outputs are the bridge between your infrastructure and the rest of your toolchain. They make Terraform a team player in your automation ecosystem." - HashiCorp

> [!tip] Pro Tip
> Output은 단순히 값을 표시하는 것이 아니라, 인프라를 다른 시스템과 통합하는 인터페이스입니다. 모듈을 설계할 때는 항상 "이 모듈의 사용자가 필요로 할 정보는 무엇인가?"를 고민하세요.