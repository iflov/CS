---
tags:
- terraform
- best-practices
- standards
- patterns
- architecture
created: 2025-01-15
updated: 2025-01-15
aliases:
- Terraform Best Practices
- 테라폼 베스트 프랙티스
description: Terraform 프로젝트의 구조, 네이밍 컨벤션, 코드 패턴 등 모범 사례 종합 가이드
status: published
category: guide
---

# Terraform 베스트 프랙티스

> [!info] 개요
> 이 가이드는 Terraform 프로젝트를 효과적으로 구성하고 유지보수하기 위한 검증된 모범 사례들을 제공합니다. 디렉토리 구조, 네이밍 컨벤션, 코드 패턴, 팀 협업 방법 등 실무에서 바로 적용할 수 있는 지침들을 다룹니다.

## 📑 목차

- [[#📁 디렉토리 구조]]
- [[#🏷️ 네이밍 컨벤션]]
- [[#📝 코드 작성 원칙]]
- [[#🔐 보안 베스트 프랙티스]]
- [[#🏗️ 모듈 설계]]
- [[#📊 State 관리]]
- [[#🔄 버전 관리]]
- [[#👥 팀 협업]]
- [[#📈 확장성 고려사항]]
- [[#✅ 체크리스트]]
- [[#📚 참고자료]]

---

## 📁 디렉토리 구조

### 표준 프로젝트 구조

> [!example] 권장 디렉토리 레이아웃
> ```
> terraform-infrastructure/
> ├── README.md                    # 프로젝트 문서
> ├── .gitignore                   # Git 제외 파일
> ├── .terraform-version           # Terraform 버전 고정
> │
> ├── environments/                # 환경별 설정
> │   ├── dev/
> │   │   ├── main.tf
> │   │   ├── variables.tf
> │   │   ├── outputs.tf
> │   │   ├── terraform.tfvars
> │   │   └── backend.tf
> │   ├── staging/
> │   └── production/
> │
> ├── modules/                     # 재사용 가능한 모듈
> │   ├── network/
> │   │   ├── README.md
> │   │   ├── main.tf
> │   │   ├── variables.tf
> │   │   ├── outputs.tf
> │   │   └── versions.tf
> │   ├── compute/
> │   ├── database/
> │   └── security/
> │
> ├── global/                      # 전역 리소스
> │   ├── iam/
> │   ├── s3/
> │   └── route53/
> │
> └── scripts/                     # 헬퍼 스크립트
>     ├── init.sh
>     ├── plan.sh
>     └── apply.sh
> ```

### 파일 구성 패턴

> [!tip] 파일별 역할 분리
> ```hcl
> # main.tf - 주요 리소스 정의
> resource "aws_vpc" "main" {
>   # ...
> }
> 
> # variables.tf - 입력 변수
> variable "environment" {
>   description = "Environment name"
>   type        = string
> }
> 
> # outputs.tf - 출력 값
> output "vpc_id" {
>   value = aws_vpc.main.id
> }
> 
> # locals.tf - 로컬 변수
> locals {
>   common_tags = {
>     Environment = var.environment
>   }
> }
> 
> # versions.tf - 버전 제약
> terraform {
>   required_version = ">= 1.0"
>   required_providers {
>     aws = {
>       source  = "hashicorp/aws"
>       version = "~> 5.0"
>     }
>   }
> }
> 
> # backend.tf - Backend 설정
> terraform {
>   backend "s3" {
>     # ...
>   }
> }
> 
> # data.tf - Data Sources
> data "aws_ami" "latest" {
>   # ...
> }
> ```

---

## 🏷️ 네이밍 컨벤션

### 리소스 네이밍

> [!success] 일관된 네이밍 규칙
> ```hcl
> # 리소스 이름: snake_case
> resource "aws_instance" "web_server" {
>   # ...
> }
> 
> # 단일 리소스: this 또는 main
> resource "aws_vpc" "main" {
>   # ...
> }
> 
> resource "aws_s3_bucket" "this" {
>   # ...
> }
> 
> # 복수 리소스: 설명적 이름
> resource "aws_subnet" "public" {
>   count = length(var.public_subnets)
>   # ...
> }
> 
> resource "aws_subnet" "private" {
>   count = length(var.private_subnets)
>   # ...
> }
> ```

### 변수 네이밍

> [!tip] 변수 명명 규칙
> ```hcl
> # 입력 변수: snake_case
> variable "instance_type" {
>   type = string
> }
> 
> # Boolean: 동사로 시작
> variable "enable_monitoring" {
>   type    = bool
>   default = false
> }
> 
> variable "create_database" {
>   type    = bool
>   default = true
> }
> 
> # 리스트/맵: 복수형
> variable "availability_zones" {
>   type = list(string)
> }
> 
> variable "instance_types" {
>   type = map(string)
> }
> 
> # 환경/설정: 명확한 접두사
> variable "db_password" {
>   type      = string
>   sensitive = true
> }
> 
> variable "app_port" {
>   type    = number
>   default = 8080
> }
> ```

### 태그 네이밍

```hcl
locals {
  # 표준 태그 세트
  common_tags = {
    Environment = var.environment
    Project     = var.project_name
    Owner       = var.owner
    CostCenter  = var.cost_center
    ManagedBy   = "Terraform"
    CreatedAt   = timestamp()
  }
  
  # 리소스별 태그
  name_prefix = "${var.project_name}-${var.environment}"
}

resource "aws_instance" "example" {
  tags = merge(
    local.common_tags,
    {
      Name = "${local.name_prefix}-instance"
      Type = "WebServer"
    }
  )
}
```

---

## 📝 코드 작성 원칙

### DRY (Don't Repeat Yourself)

> [!note] 코드 중복 제거
> ```hcl
> # 나쁜 예 - 중복된 코드
> resource "aws_instance" "web1" {
>   ami           = "ami-123456"
>   instance_type = "t3.micro"
>   subnet_id     = aws_subnet.public[0].id
>   
>   tags = {
>     Name = "web-1"
>   }
> }
> 
> resource "aws_instance" "web2" {
>   ami           = "ami-123456"
>   instance_type = "t3.micro"
>   subnet_id     = aws_subnet.public[1].id
>   
>   tags = {
>     Name = "web-2"
>   }
> }
> 
> # 좋은 예 - count 사용
> resource "aws_instance" "web" {
>   count = 2
>   
>   ami           = "ami-123456"
>   instance_type = "t3.micro"
>   subnet_id     = aws_subnet.public[count.index].id
>   
>   tags = {
>     Name = "web-${count.index + 1}"
>   }
> }
> 
> # 더 좋은 예 - for_each 사용
> variable "instances" {
>   default = {
>     web1 = { subnet_index = 0 }
>     web2 = { subnet_index = 1 }
>   }
> }
> 
> resource "aws_instance" "web" {
>   for_each = var.instances
>   
>   ami           = "ami-123456"
>   instance_type = "t3.micro"
>   subnet_id     = aws_subnet.public[each.value.subnet_index].id
>   
>   tags = {
>     Name = each.key
>   }
> }
> ```

### 명시적 의존성

```hcl
# 암시적 의존성 활용 (권장)
resource "aws_instance" "app" {
  subnet_id = aws_subnet.private.id  # 자동 의존성
  # ...
}

# 필요시 명시적 의존성 추가
resource "aws_instance" "app" {
  # ...
  
  depends_on = [
    aws_iam_role_policy.app,
    aws_db_instance.database
  ]
}
```

### 조건부 리소스

> [!tip] 조건부 생성 패턴
> ```hcl
> # count를 이용한 조건부
> resource "aws_instance" "bastion" {
>   count = var.create_bastion ? 1 : 0
>   # ...
> }
> 
> # for_each를 이용한 조건부
> resource "aws_route53_record" "www" {
>   for_each = var.create_dns_record ? toset(["create"]) : toset([])
>   # ...
> }
> 
> # 동적 블록
> resource "aws_security_group" "example" {
>   name = "example"
>   
>   dynamic "ingress" {
>     for_each = var.enable_https ? [443] : []
>     content {
>       from_port   = ingress.value
>       to_port     = ingress.value
>       protocol    = "tcp"
>       cidr_blocks = ["0.0.0.0/0"]
>     }
>   }
> }
> ```

---

## 🔐 보안 베스트 프랙티스

### 민감한 데이터 관리

> [!danger] 보안 원칙
> ```hcl
> # variables.tf
> variable "db_password" {
>   description = "Database password"
>   type        = string
>   sensitive   = true  # 민감한 변수 표시
> }
> 
> # 환경변수 사용
> # export TF_VAR_db_password="SecurePassword123!"
> 
> # 절대 하지 말아야 할 것
> # ❌ 하드코딩
> # resource "aws_db_instance" "example" {
> #   password = "plaintext-password"  # 절대 금지!
> # }
> 
> # ✅ Secrets Manager 사용
> resource "random_password" "db" {
>   length  = 32
>   special = true
> }
> 
> resource "aws_secretsmanager_secret" "db_password" {
>   name = "${var.environment}-db-password"
> }
> 
> resource "aws_secretsmanager_secret_version" "db_password" {
>   secret_id     = aws_secretsmanager_secret.db_password.id
>   secret_string = random_password.db.result
> }
> ```

### IAM 최소 권한

```hcl
# 최소 권한 원칙
resource "aws_iam_role" "app" {
  name = "${var.app_name}-role"
  
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Action = "sts:AssumeRole"
      Effect = "Allow"
      Principal = {
        Service = "ec2.amazonaws.com"
      }
    }]
  })
}

resource "aws_iam_role_policy" "app" {
  name = "${var.app_name}-policy"
  role = aws_iam_role.app.id
  
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "s3:GetObject",
          "s3:ListBucket"
        ]
        Resource = [
          aws_s3_bucket.app.arn,
          "${aws_s3_bucket.app.arn}/*"
        ]
      }
    ]
  })
}
```

---

## 🏗️ 모듈 설계

### 모듈 인터페이스

> [!success] 잘 설계된 모듈
> ```hcl
> # modules/vpc/variables.tf
> variable "vpc_cidr" {
>   description = "CIDR block for VPC"
>   type        = string
>   
>   validation {
>     condition     = can(cidrhost(var.vpc_cidr, 0))
>     error_message = "Must be a valid IPv4 CIDR block."
>   }
> }
> 
> variable "environment" {
>   description = "Environment name"
>   type        = string
>   
>   validation {
>     condition     = contains(["dev", "staging", "prod"], var.environment)
>     error_message = "Environment must be dev, staging, or prod."
>   }
> }
> 
> # 합리적인 기본값 제공
> variable "enable_nat_gateway" {
>   description = "Enable NAT Gateway for private subnets"
>   type        = bool
>   default     = true
> }
> 
> variable "single_nat_gateway" {
>   description = "Use a single NAT Gateway for all private subnets"
>   type        = bool
>   default     = false  # 프로덕션은 false, 개발은 true 권장
> }
> ```

### 모듈 버전 관리

```hcl
# 모듈 사용 시 버전 명시
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "5.0.0"  # 정확한 버전 지정
  
  # Git 레포지토리 사용
  # source = "git::https://github.com/example/modules.git//vpc?ref=v1.0.0"
  
  # ...
}
```

---

## 📊 State 관리

### Remote State 설정

> [!warning] State 관리 원칙
> ```hcl
> # backend.tf
> terraform {
>   backend "s3" {
>     bucket         = "terraform-state-bucket"
>     key            = "env/prod/terraform.tfstate"
>     region         = "us-west-2"
>     encrypt        = true
>     kms_key_id     = "arn:aws:kms:..."
>     dynamodb_table = "terraform-state-lock"
>     
>     # 버전 관리 활성화
>     versioning = true
>     
>     # 액세스 로깅
>     logging {
>       target_bucket = "terraform-state-logs"
>       target_prefix = "state/"
>     }
>   }
> }
> ```

### State 분리 전략

```
# 레이어별 State 분리
terraform/
├── network/
│   └── terraform.tfstate  # 네트워크 인프라
├── data/
│   └── terraform.tfstate  # 데이터베이스, 스토리지
├── compute/
│   └── terraform.tfstate  # EC2, ECS, Lambda
└── monitoring/
    └── terraform.tfstate  # CloudWatch, 알람
```

---

## 🔄 버전 관리

### Git 전략

> [!tip] 브랜치 전략
> ```bash
> # .gitignore
> *.tfstate
> *.tfstate.*
> *.tfplan
> .terraform/
> .terraform.lock.hcl  # 팀 환경에 따라 포함/제외 결정
> *.tfvars  # 민감한 정보가 있을 경우
> !example.tfvars
> 
> # 브랜치 구조
> main          # 프로덕션
> ├── develop   # 개발 환경
> ├── staging   # 스테이징 환경
> └── feature/* # 기능 개발
> ```

### 커밋 메시지 컨벤션

```bash
# 좋은 커밋 메시지
feat: Add auto-scaling configuration for web tier
fix: Correct security group rules for RDS
docs: Update README with deployment instructions
refactor: Simplify VPC module interface
chore: Update AWS provider to v5.0

# 형식
<type>: <subject>

<body>

<footer>
```

---

## 👥 팀 협업

### 코드 리뷰 체크리스트

> [!success] PR 리뷰 포인트
> - [ ] 네이밍 컨벤션 준수
> - [ ] 민감한 정보 하드코딩 없음
> - [ ] 적절한 변수 기본값
> - [ ] 출력 값 정의
> - [ ] 문서화 (README, 주석)
> - [ ] terraform fmt 실행
> - [ ] terraform validate 통과
> - [ ] 보안 스캔 통과 (tfsec, checkov)
> - [ ] 비용 영향 검토
> - [ ] 롤백 계획 수립

### 문서화

```markdown
# 모듈 README.md 템플릿

## Overview
이 모듈의 목적과 기능 설명

## Requirements
- Terraform >= 1.0
- AWS Provider >= 5.0

## Usage
​```hcl
module "example" {
  source = "./modules/example"
  
  # 필수 변수
  environment = "production"
  vpc_id      = "vpc-123456"
}
​```

## Inputs
| Name | Description | Type | Default | Required |
|------|-------------|------|---------|----------|
| environment | Environment name | string | - | yes |
| vpc_id | VPC ID | string | - | yes |

## Outputs
| Name | Description |
|------|-------------|
| instance_id | EC2 instance ID |
| public_ip | Public IP address |

## Examples
See `examples/` directory

## License
MIT
```

---

## 📈 확장성 고려사항

### 대규모 인프라 관리

> [!note] 확장성 패턴
> ```hcl
> # 동적 구성
> locals {
>   # 환경별 설정
>   env_config = {
>     dev = {
>       instance_count = 2
>       instance_type  = "t3.micro"
>     }
>     prod = {
>       instance_count = 10
>       instance_type  = "t3.large"
>     }
>   }
>   
>   config = local.env_config[var.environment]
> }
> 
> # 리소스 제한 고려
> resource "aws_instance" "app" {
>   count = min(local.config.instance_count, 20)  # AWS 제한 고려
>   # ...
> }
> ```

### 성능 최적화

```hcl
# 병렬 처리 최적화
terraform {
  # 대규모 인프라에서 병렬 처리 증가
  experiments = [module_variable_optional_attrs]
}

# 리소스 생성 최적화
resource "aws_instance" "workers" {
  count = var.worker_count
  
  # 병렬 생성을 위한 의존성 최소화
  ami           = data.aws_ami.latest.id
  instance_type = var.instance_type
  
  # 타이밍 이슈 방지
  provisioner "local-exec" {
    command = "sleep 5"
  }
  
  lifecycle {
    create_before_destroy = true
  }
}
```

---

## ✅ 체크리스트

> [!success] Terraform 프로젝트 체크리스트
> 
> **프로젝트 구조**
> - [ ] 명확한 디렉토리 구조
> - [ ] 환경별 분리
> - [ ] 모듈화
> - [ ] README 문서
> 
> **코드 품질**
> - [ ] terraform fmt 적용
> - [ ] terraform validate 통과
> - [ ] 네이밍 컨벤션 준수
> - [ ] DRY 원칙 적용
> - [ ] 적절한 주석
> 
> **보안**
> - [ ] 민감한 정보 보호
> - [ ] 최소 권한 원칙
> - [ ] 보안 스캔 통과
> - [ ] State 암호화
> 
> **운영**
> - [ ] Remote State 설정
> - [ ] State 잠금 설정
> - [ ] 백업 전략
> - [ ] 모니터링 설정
> - [ ] 태깅 전략
> 
> **협업**
> - [ ] 버전 관리
> - [ ] CI/CD 파이프라인
> - [ ] 코드 리뷰 프로세스
> - [ ] 문서화

---

## 📚 참고자료

### 관련 문서
- [[01. Terraform 기초]]
- [[09. Terraform 모듈]]
- [[12. Terraform 보안]]
- [[13. Terraform CICD]]
- [[14. Terraform 트러블슈팅]]

### 외부 리소스
- [Terraform Best Practices by Google](https://cloud.google.com/docs/terraform/best-practices-for-terraform)
- [Terraform Style Guide](https://www.terraform.io/docs/language/syntax/style.html)
- [The Terraform Book](https://terraformbook.com/)
- [Gruntwork Terraform Style Guide](https://docs.gruntwork.io/guides/style/terraform-style-guide/)

---

> [!quote]
> "최고의 코드는 자명한 코드입니다. 주석이 필요 없을 정도로 명확하고, 구조가 직관적이며, 의도가 분명한 코드를 작성하세요."