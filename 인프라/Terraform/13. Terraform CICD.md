## 🦊 GitLab CI

### GitLab Pipeline 설정

> [!example] .gitlab-ci.yml
> ```yaml
> # .gitlab-ci.yml
> variables:
>   TF_VERSION: "1.5.0"
>   TF_IN_AUTOMATION: "true"
>   TF_ROOT: ${CI_PROJECT_DIR}
> 
> stages:
>   - validate
>   - test
>   - plan
>   - apply
>   - destroy
> 
> image:
>   name: hashicorp/terraform:${TF_VERSION}
>   entrypoint:
>     - /usr/bin/env
>     - "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
> 
> cache:
>   paths:
>     - .terraform
>     - .terraform.lock.hcl
> 
> before_script:
>   - terraform --version
>   - terraform init
> 
> # Validate Stage
> format:
>   stage: validate
>   script:
>     - terraform fmt -check=true -diff=true
>   only:
>     - merge_requests
> 
> validate:
>   stage: validate
>   script:
>     - terraform validate
>   only:
>     - merge_requests
> 
> # Test Stage
> tfsec:
>   stage: test
>   image: aquasec/tfsec:latest
>   script:
>     - tfsec . --format json --out tfsec-report.json
>   artifacts:
>     reports:
>       security: tfsec-report.json
>   only:
>     - merge_requests
> 
> checkov:
>   stage: test
>   image: bridgecrew/checkov:latest
>   script:
>     - checkov -d . --output junitxml --output-file-path checkov-report.xml
>   artifacts:
>     reports:
>       junit: checkov-report.xml
>   only:
>     - merge_requests
> 
> # Plan Stage
> plan:development:
>   stage: plan
>   script:
>     - terraform workspace select development || terraform workspace new development
>     - terraform plan -out=plan.tfplan
>     - terraform show -no-color plan.tfplan > plan.txt
>   artifacts:
>     paths:
>       - plan.tfplan
>       - plan.txt
>     expire_in: 1 week
>   only:
>     - develop
> 
> plan:production:
>   stage: plan
>   script:
>     - terraform workspace select production || terraform workspace new production
>     - terraform plan -out=plan.tfplan
>     - terraform show -no-color plan.tfplan > plan.txt
>   artifacts:
>     paths:
>       - plan.tfplan
>       - plan.txt
>     expire_in: 1 week
>   only:
>     - main
> 
> # Apply Stage
> apply:development:
>   stage: apply
>   script:
>     - terraform workspace select development
>     - terraform apply plan.tfplan
>   dependencies:
>     - plan:development
>   environment:
>     name: development
>     url: https://dev.example.com
>   when: manual
>   only:
>     - develop
> 
> apply:production:
>   stage: apply
>   script:
>     - terraform workspace select production
>     - terraform apply plan.tfplan
>   dependencies:
>     - plan:production
>   environment:
>     name: production
>     url: https://example.com
>   when: manual
>   only:
>     - main
> 
> # Destroy Stage (Manual)
> destroy:development:
>   stage: destroy
>   script:
>     - terraform workspace select development
>     - terraform destroy -auto-approve
>   environment:
>     name: development
>     action: stop
>   when: manual
>   only:
>     - develop
> ```

### GitLab 환경별 변수

```yaml
# CI/CD Settings > Variables에서 설정
variables:
  AWS_ACCESS_KEY_ID: $AWS_ACCESS_KEY_ID_DEV      # Development
  AWS_SECRET_ACCESS_KEY: $AWS_SECRET_ACCESS_KEY_DEV
  
  AWS_ACCESS_KEY_ID_PROD: $AWS_ACCESS_KEY_ID_PROD # Production
  AWS_SECRET_ACCESS_KEY_PROD: $AWS_SECRET_ACCESS_KEY_PROD
```

---

## 🌊 Atlantis

### Atlantis 설정

> [!tip] Atlantis 서버 구성
> ```yaml
> # atlantis.yaml (repo root)
> version: 3
> projects:
>   - name: infrastructure
>     dir: .
>     workspace: default
>     terraform_version: v1.5.0
>     
>     autoplan:
>       when_modified: ["*.tf", "*.tfvars"]
>       enabled: true
>     
>     workflow: custom
>     
> workflows:
>   custom:
>     plan:
>       steps:
>         - env:
>             name: TF_VAR_environment
>             command: echo ${ATLANTIS_PULL_NUM}
>         - init
>         - run: terraform fmt -check=true
>         - run: tflint
>         - run: tfsec .
>         - plan
>     
>     apply:
>       steps:
>         - apply
> 
> # repo 설정
> repos:
>   - id: github.com/example/infrastructure
>     allowed_overrides: [workflow, apply_requirements]
>     allow_custom_workflows: true
>     
>     apply_requirements: [approved, mergeable]
>     
>     pre_workflow_hooks:
>       - run: echo "Starting Atlantis workflow for PR ${PULL_NUM}"
>     
>     post_workflow_hooks:
>       - run: |
>           curl -X POST https://api.slack.com/webhook \
>             -d '{"text":"Terraform applied successfully"}'
> ```

### Atlantis Docker Compose

> [!example] Atlantis 로컬 실행
> ```yaml
> # docker-compose.yml
> version: '3.8'
> 
> services:
>   atlantis:
>     image: ghcr.io/runatlantis/atlantis:latest
>     container_name: atlantis
>     ports:
>       - "4141:4141"
>     environment:
>       - ATLANTIS_REPO_ALLOWLIST=github.com/your-org/*
>       - ATLANTIS_GH_USER=${GITHUB_USER}
>       - ATLANTIS_GH_TOKEN=${GITHUB_TOKEN}
>       - ATLANTIS_GH_WEBHOOK_SECRET=${WEBHOOK_SECRET}
>       - ATLANTIS_PORT=4141
>       - ATLANTIS_ATLANTIS_URL=https://atlantis.example.com
>       - AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
>       - AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
>     volumes:
>       - atlantis-data:/atlantis-data
>     restart: unless-stopped
> 
> volumes:
>   atlantis-data:
> ```

---

## ☁️ Terraform Cloud

### Terraform Cloud 워크플로우

> [!example] VCS 통합 설정
> ```hcl
> # backend.tf
> terraform {
>   cloud {
>     organization = "example-org"
>     
>     workspaces {
>       name = "production"
>     }
>   }
> }
> 
> # 또는 태그 기반
> terraform {
>   cloud {
>     organization = "example-org"
>     
>     workspaces {
>       tags = ["app:myapp", "env:prod"]
>     }
>   }
> }
> ```

### Terraform Cloud API 자동화

```bash
#!/bin/bash
# trigger-run.sh

# Terraform Cloud API 토큰
TOKEN="your-api-token"
ORG="your-org"
WORKSPACE="your-workspace"

# Run 트리거
curl \
  --header "Authorization: Bearer $TOKEN" \
  --header "Content-Type: application/vnd.api+json" \
  --request POST \
  --data '{
    "data": {
      "attributes": {
        "message": "Triggered via API",
        "auto-apply": false
      },
      "type": "runs",
      "relationships": {
        "workspace": {
          "data": {
            "type": "workspaces",
            "id": "'$WORKSPACE'"
          }
        }
      }
    }
  }' \
  https://app.terraform.io/api/v2/runs
```

### Sentinel Policy

> [!warning] Policy as Code
> ```hcl
> # sentinel.hcl
> module "tfplan-functions" {
>   source = "./common-functions/tfplan-functions/tfplan-functions.sentinel"
> }
> 
> policy "restrict-ec2-instance-type" {
>   source = "./restrict-ec2-instance-type.sentinel"
>   enforcement_level = "soft-mandatory"
> }
> 
> policy "enforce-mandatory-tags" {
>   source = "./enforce-mandatory-tags.sentinel"
>   enforcement_level = "hard-mandatory"
> }
> ```

---

## 🚀 Jenkins Pipeline

### Jenkinsfile

> [!example] Jenkins Pipeline
> ```groovy
> // Jenkinsfile
> pipeline {
>     agent any
>     
>     environment {
>         TF_VERSION = '1.5.0'
>         AWS_REGION = 'us-west-2'
>         TF_IN_AUTOMATION = 'true'
>     }
>     
>     tools {
>         terraform 'terraform-1.5.0'
>     }
>     
>     stages {
>         stage('Checkout') {
>             steps {
>                 checkout scm
>             }
>         }
>         
>         stage('Terraform Init') {
>             steps {
>                 sh '''
>                     terraform init \
>                         -backend-config="bucket=${BACKEND_BUCKET}" \
>                         -backend-config="key=${env.BRANCH_NAME}/terraform.tfstate"
>                 '''
>             }
>         }
>         
>         stage('Terraform Format') {
>             steps {
>                 sh 'terraform fmt -check=true -diff=true'
>             }
>         }
>         
>         stage('Terraform Validate') {
>             steps {
>                 sh 'terraform validate'
>             }
>         }
>         
>         stage('Security Scan') {
>             parallel {
>                 stage('tfsec') {
>                     steps {
>                         sh 'docker run --rm -v $(pwd):/src aquasec/tfsec /src'
>                     }
>                 }
>                 stage('checkov') {
>                     steps {
>                         sh 'docker run --rm -v $(pwd):/tf bridgecrew/checkov -d /tf'
>                     }
>                 }
>             }
>         }
>         
>         stage('Terraform Plan') {
>             steps {
>                 script {
>                     def planOutput = sh(
>                         script: 'terraform plan -out=tfplan',
>                         returnStdout: true
>                     )
>                     
>                     // Plan을 아티팩트로 저장
>                     archiveArtifacts artifacts: 'tfplan'
>                     
>                     // PR에 코멘트 (GitHub 플러그인 사용)
>                     if (env.CHANGE_ID) {
>                         pullRequest.comment("Terraform Plan:\n```\n${planOutput}\n```")
>                     }
>                 }
>             }
>         }
>         
>         stage('Approval') {
>             when {
>                 branch 'main'
>             }
>             steps {
>                 input message: 'Apply Terraform?', ok: 'Apply'
>             }
>         }
>         
>         stage('Terraform Apply') {
>             when {
>                 branch 'main'
>             }
>             steps {
>                 sh 'terraform apply tfplan'
>             }
>         }
>         
>         stage('Post Actions') {
>             steps {
>                 script {
>                     // Slack 알림
>                     slackSend(
>                         channel: '#infrastructure',
>                         color: 'good',
>                         message: "Terraform applied successfully for ${env.BRANCH_NAME}"
>                     )
>                     
>                     // Output 저장
>                     sh 'terraform output -json > outputs.json'
>                     archiveArtifacts artifacts: 'outputs.json'
>                 }
>             }
>         }
>     }
>     
>     post {
>         always {
>             cleanWs()
>         }
>         failure {
>             slackSend(
>                 channel: '#infrastructure',
>                 color: 'danger',
>                 message: "Terraform pipeline failed for ${env.BRANCH_NAME}"
>             )
>         }
>     }
> }
> ```

---

## 🔧 자동화 도구 비교

> [!note] CI/CD 도구 선택 가이드
> 
> | 도구 | 장점 | 단점 | 적합한 경우 |
> |------|------|------|------------|
> | **GitHub Actions** | - GitHub 통합<br>- 무료 티어<br>- 간단한 설정 | - GitHub 종속<br>- 복잡한 워크플로우 제한 | GitHub 사용 팀 |
> | **GitLab CI** | - GitLab 통합<br>- 강력한 기능<br>- 자체 호스팅 가능 | - 학습 곡선<br>- 리소스 소비 | GitLab 사용 팀 |
> | **Atlantis** | - PR 기반 워크플로우<br>- 자동 Plan<br>- 락 메커니즘 | - 설정 복잡<br>- 자체 호스팅 필요 | 대규모 팀 |
> | **Terraform Cloud** | - 관리형 서비스<br>- 상태 관리<br>- Sentinel 정책 | - 비용<br>- 인터넷 연결 필요 | 엔터프라이즈 |
> | **Jenkins** | - 유연성<br>- 플러그인 생태계<br>- 온프레미스 | - 유지보수<br>- 설정 복잡 | 기존 Jenkins 사용 |

---

## 💡 실전 파이프라인

### 멀티 환경 배포

> [!example] 환경별 자동 배포
> ```yaml
> # .github/workflows/multi-env.yml
> name: Multi-Environment Deploy
> 
> on:
>   push:
>     branches:
>       - develop
>       - staging
>       - main
> 
> jobs:
>   determine-environment:
>     runs-on: ubuntu-latest
>     outputs:
>       environment: ${{ steps.env.outputs.environment }}
>     steps:
>       - id: env
>         run: |
>           if [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
>             echo "environment=development" >> $GITHUB_OUTPUT
>           elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
>             echo "environment=staging" >> $GITHUB_OUTPUT
>           elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
>             echo "environment=production" >> $GITHUB_OUTPUT
>           fi
>   
>   deploy:
>     needs: determine-environment
>     runs-on: ubuntu-latest
>     environment: ${{ needs.determine-environment.outputs.environment }}
>     
>     steps:
>       - uses: actions/checkout@v3
>       
>       - name: Setup Terraform
>         uses: hashicorp/setup-terraform@v2
>       
>       - name: Terraform Init
>         run: |
>           terraform init \
>             -backend-config="key=${{ needs.determine-environment.outputs.environment }}/terraform.tfstate"
>       
>       - name: Terraform Apply
>         run: |
>           terraform apply \
>             -var-file="environments/${{ needs.determine-environment.outputs.environment }}.tfvars" \
>             -auto-approve
> ```

### 블루-그린 배포

> [!tip] 무중단 배포 전략
> ```hcl
> # blue-green.tf
> variable "active_environment" {
>   description = "Currently active environment (blue or green)"
>   default     = "blue"
> }
> 
> locals {
>   inactive_environment = var.active_environment == "blue" ? "green" : "blue"
> }
> 
> # Blue 환경
> module "blue" {
>   source = "./modules/environment"
>   count  = var.active_environment == "blue" ? 1 : 0
>   
>   environment = "blue"
>   is_active   = true
> }
> 
> # Green 환경
> module "green" {
>   source = "./modules/environment"
>   count  = var.active_environment == "green" ? 1 : 0
>   
>   environment = "green"
>   is_active   = true
> }
> 
> # 트래픽 전환
> resource "aws_route53_record" "app" {
>   zone_id = var.zone_id
>   name    = "app.example.com"
>   type    = "A"
>   
>   alias {
>     name    = var.active_environment == "blue" ? module.blue[0].alb_dns : module.green[0].alb_dns
>     zone_id = var.active_environment == "blue" ? module.blue[0].alb_zone_id : module.green[0].alb_zone_id
>     evaluate_target_health = true
>   }
> }
> ```

---

## ✨ 베스트 프랙티스

> [!success] CI/CD 권장사항
> 
> **워크플로우 설계**
> - [ ] PR 기반 워크플로우 구현
> - [ ] 환경별 브랜치 전략 수립
> - [ ] 자동 롤백 메커니즘 구현
> - [ ] 승인 프로세스 정의
> 
> **보안**
> - [ ] 시크릿 관리 도구 사용
> - [ ] 최소 권한 원칙 적용
> - [ ] 보안 스캔 자동화
> - [ ] 감사 로그 유지
> 
> **품질 관리**
> - [ ] 코드 포맷팅 검사
> - [ ] 유효성 검증
> - [ ] 정적 분석 도구 실행
> - [ ] 테스트 자동화
> 
> **모니터링**
> - [ ] 파이프라인 메트릭 수집
> - [ ] 실패 알림 설정
> - [ ] 배포 추적
> - [ ] 비용 모니터링

---

## 📚 참고자료

### 관련 문서
- [[Terraform 기초]]
- [[12. Terraform 보안]]
- [[10. Terraform 워크스페이스]]

### 외부 리소스
- [Atlantis Documentation](https://www.runatlantis.io/)
- [Terraform Cloud Documentation](https://www.terraform.io/cloud)
- [GitHub Actions for Terraform](https://github.com/hashicorp/setup-terraform)
- [GitLab CI/CD Documentation](https://docs.gitlab.com/ee/ci/)

---

> [!quote]
> "자동화는 인간의 실수를 줄이고, 일관성을 보장하며, 팀이 더 중요한 일에 집중할 수 있게 합니다."